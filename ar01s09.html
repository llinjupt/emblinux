<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>9. &#20869;&#26680;&#21021;&#22987;&#21270;</title><link rel="stylesheet" href="styles.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="Linux&#20869;&#26680;&#23398;&#20064;&#21644;&#30740;&#31350;&#21450;&#23884;&#20837;&#24335;(ARM)&#23398;&#20064;&#21644;&#30740;&#31350;&#30340;&#24320;&#25918;&#25991;&#26723;"><link rel="up" href="index.html" title="Linux&#20869;&#26680;&#23398;&#20064;&#21644;&#30740;&#31350;&#21450;&#23884;&#20837;&#24335;(ARM)&#23398;&#20064;&#21644;&#30740;&#31350;&#30340;&#24320;&#25918;&#25991;&#26723;"><link rel="prev" href="ar01s08.html" title="8. &#20869;&#26680;&#21152;&#36733;"><link rel="next" href="ar01s10.html" title="10. Bootmem&#26426;&#21046;"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">9. &#20869;&#26680;&#21021;&#22987;&#21270;</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ar01s08.html">&#19978;&#19968;&#39029;</a> </td><th width="60%" align="center"> </th><td width="20%" align="right"> <a accesskey="n" href="ar01s10.html">&#19979;&#19968;&#39029;</a></td></tr></table><hr></div><div class="sect1" title="9. &#20869;&#26680;&#21021;&#22987;&#21270;"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="idp80601060"></a>9. &#20869;&#26680;&#21021;&#22987;&#21270;</h2></div></div></div>
start_kernel&#26159;&#19968;&#20010;&#38750;&#24120;&#37325;&#35201;&#30340;&#21021;&#22987;&#21270;&#20989;&#25968;&#21644;&#24341;&#23548;&#20989;&#25968;&#12290;&#22312;start_kernel()&#20989;&#25968;&#20013;&#65306;
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">&#36755;&#20986;Linux&#29256;&#26412;&#20449;&#24687;&#65288;printk(linux_banner)&#65289; </li><li class="listitem">&#35774;&#32622;&#19982;&#20307;&#31995;&#32467;&#26500;&#30456;&#20851;&#30340;&#29615;&#22659;&#65288;setup_arch()&#65289; </li><li class="listitem">&#39029;&#34920;&#32467;&#26500;&#21021;&#22987;&#21270;&#65288;paging_init()&#65289; </li><li class="listitem">&#20351;&#29992;"arch/alpha/kernel/entry.S"&#20013;&#30340;&#20837;&#21475;&#28857;&#35774;&#32622;&#31995;&#32479;&#33258;&#38519;&#20837;&#21475;&#65288;trap_init()&#65289; </li><li class="listitem">&#20351;&#29992;alpha_mv&#32467;&#26500;&#21644;entry.S&#20837;&#21475;&#21021;&#22987;&#21270;&#31995;&#32479;IRQ&#65288;init_IRQ()&#65289; </li><li class="listitem">&#26680;&#24515;&#36827;&#31243;&#35843;&#24230;&#22120;&#21021;&#22987;&#21270;&#65288;&#21253;&#25324;&#21021;&#22987;&#21270;&#20960;&#20010;&#32570;&#30465;&#30340;Bottom-half&#65292;sched_init()&#65289; </li><li class="listitem">&#26102;&#38388;&#12289;&#23450;&#26102;&#22120;&#21021;&#22987;&#21270;&#65288;&#21253;&#25324;&#35835;&#21462;CMOS&#26102;&#38047;&#12289;&#20272;&#27979;&#20027;&#39057;&#12289;&#21021;&#22987;&#21270;&#23450;&#26102;&#22120;&#20013;&#26029;&#31561;&#65292;time_init()&#65289; </li><li class="listitem">&#25552;&#21462;&#24182;&#20998;&#26512;&#26680;&#24515;&#21551;&#21160;&#21442;&#25968;&#65288;&#20174;&#29615;&#22659;&#21464;&#37327;&#20013;&#35835;&#21462;&#21442;&#25968;&#65292;&#35774;&#32622;&#30456;&#24212;&#26631;&#24535;&#20301;&#31561;&#24453;&#22788;&#29702;&#65292;&#65288;parse_options()&#65289; </li><li class="listitem">&#25511;&#21046;&#21488;&#21021;&#22987;&#21270;&#65288;&#20026;&#36755;&#20986;&#20449;&#24687;&#32780;&#20808;&#20110;PCI&#21021;&#22987;&#21270;&#65292;console_init()&#65289; </li><li class="listitem">&#21078;&#26512;&#22120;&#25968;&#25454;&#32467;&#26500;&#21021;&#22987;&#21270;&#65288;prof_buffer&#21644;prof_len&#21464;&#37327;&#65289; </li><li class="listitem">&#26680;&#24515;Cache&#21021;&#22987;&#21270;&#65288;&#25551;&#36848;Cache&#20449;&#24687;&#30340;Cache&#65292;kmem_cache_init()&#65289; </li><li class="listitem">&#24310;&#36831;&#26657;&#20934;&#65288;&#33719;&#24471;&#26102;&#38047;jiffies&#19982;CPU&#20027;&#39057;ticks&#30340;&#24310;&#36831;&#65292;calibrate_delay()&#65289;</li><li class="listitem">&#20869;&#23384;&#21021;&#22987;&#21270;&#65288;&#35774;&#32622;&#20869;&#23384;&#19978;&#19979;&#30028;&#21644;&#39029;&#34920;&#39033;&#21021;&#22987;&#20540;&#65292;mem_init()&#65289; </li><li class="listitem">&#21019;&#24314;&#21644;&#35774;&#32622;&#20869;&#37096;&#21450;&#36890;&#29992;cache&#65288;"slab_cache"&#65292;kmem_cache_sizes_init()&#65289; </li><li class="listitem">&#21019;&#24314;uid taskcount SLAB cache&#65288;"uid_cache"&#65292;uidcache_init()&#65289; </li><li class="listitem">&#21019;&#24314;&#25991;&#20214;cache&#65288;"files_cache"&#65292;filescache_init()&#65289; </li><li class="listitem">&#21019;&#24314;&#30446;&#24405;cache&#65288;"dentry_cache"&#65292;dcache_init()&#65289; </li><li class="listitem">&#21019;&#24314;&#19982;&#34394;&#23384;&#30456;&#20851;&#30340;cache&#65288;"vm_area_struct"&#65292;"mm_struct"&#65292;vma_init()&#65289; </li><li class="listitem">&#22359;&#35774;&#22791;&#35835;&#20889;&#32531;&#20914;&#21306;&#21021;&#22987;&#21270;&#65288;&#21516;&#26102;&#21019;&#24314;"buffer_head"cache&#29992;&#25143;&#21152;&#36895;&#35775;&#38382;&#65292;buffer_init()&#65289; </li><li class="listitem">&#21019;&#24314;&#39029;cache&#65288;&#20869;&#23384;&#39029;hash&#34920;&#21021;&#22987;&#21270;&#65292;page_cache_init()&#65289; </li><li class="listitem">&#21019;&#24314;&#20449;&#21495;&#38431;&#21015;cache&#65288;"signal_queue"&#65292;signals_init()&#65289; </li><li class="listitem">&#21021;&#22987;&#21270;&#20869;&#23384;inode&#34920;&#65288;inode_init()&#65289; </li><li class="listitem">&#21019;&#24314;&#20869;&#23384;&#25991;&#20214;&#25551;&#36848;&#31526;&#34920;&#65288;"filp_cache"&#65292;file_table_init()&#65289; </li><li class="listitem">&#26816;&#26597;&#20307;&#31995;&#32467;&#26500;&#28431;&#27934;&#65288;&#23545;&#20110;alpha&#65292;&#27492;&#20989;&#25968;&#20026;&#31354;&#65292;check_bugs()&#65289; </li><li class="listitem">SMP&#26426;&#22120;&#20854;&#20313;CPU&#65288;&#38500;&#24403;&#21069;&#24341;&#23548;CPU&#65289;&#21021;&#22987;&#21270;&#65288;&#23545;&#20110;&#27809;&#26377;&#37197;&#32622;SMP&#30340;&#20869;&#26680;&#65292;&#27492;&#20989;&#25968;&#20026;&#31354;&#65292;smp_init()&#65289; </li><li class="listitem">&#21551;&#21160;init&#36807;&#31243;&#65288;&#21019;&#24314;&#31532;&#19968;&#20010;&#26680;&#24515;&#32447;&#31243;&#65292;&#35843;&#29992;init()&#20989;&#25968;&#65292;&#21407;&#25191;&#34892;&#24207;&#21015;&#35843;&#29992;cpu_idle() &#31561;&#24453;&#35843;&#24230;&#65292;init()&#65289; </li></ul></div>
&#19979;&#38754;&#23558;&#26681;&#25454;start_kernel&#35843;&#29992;&#19968;&#20123;&#21015;&#21021;&#22987;&#21270;&#20989;&#25968;&#30340;&#27969;&#31243;&#65292;&#19968;&#19968;&#20998;&#26512;&#12290;start_kernel&#30340;&#24320;&#22987;&#30340;&#20960;&#20010;&#20989;&#25968;&#37117;&#26159;&#31354;&#20989;&#25968;&#65292;&#31532;&#19968;&#20010;&#26377;&#25928;&#30340;&#20989;&#25968;&#26159;local_irq_disable&#65292;&#23427;&#36890;&#36807;&#27719;&#32534;&#25351;&#20196;cpsid i&#20851;&#20013;&#26029;&#12290;&#19968;&#20123;&#21021;&#22987;&#21270;&#30340;&#21160;&#20316;&#24517;&#39035;&#22312;&#20851;&#20013;&#26029;&#19979;&#36827;&#34892;&#12290;
<pre class="programlisting">
asmlinkage void __init start_kernel(void)
{
	char * command_line;
	extern struct kernel_param __start___param[], __stop___param[];
	
	smp_setup_processor_id();

	unwind_init();
	lockdep_init();
	debug_objects_early_init();
	cgroup_init_early();

	local_irq_disable();
	early_boot_irqs_off();
	early_init_irq_lock_class();
/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */
	lock_kernel();
	tick_init();
	boot_cpu_init();
	page_address_init();
	......	
</pre>	
<div class="sect2" title="9.1. CPU&#25513;&#30721;"><div class="titlepage"><div><div><h3 class="title"><a name="idp80610540"></a>9.1. CPU&#25513;&#30721;</h3></div></div></div>	
<p>
&#24403;&#21069;&#31995;&#32479;&#30340;&#25152;&#26377;CPU&#22343;&#36890;&#36807;&#19968;&#20123;&#34987;&#22768;&#26126;&#20026;&#20840;&#23616;&#21464;&#37327;&#30340;&#25513;&#30721;&#26469;&#36827;&#34892;&#35760;&#24405;&#65292;&#22788;&#20110;&#19981;&#21516;&#29366;&#24577;&#30340;CPU&#23558;&#23545;&#24212;&#19981;&#21516;&#30340;&#25513;&#30721;&#12290;boot_cpu_init&#20989;&#25968;&#35774;&#32622;&#24403;&#21069;CPU&#21040;online&#65292;present&#21644;possible&#25513;&#30721;&#20013;&#12290;&#23427;&#20204;&#20998;&#21035;&#34920;&#31034;&#27491;&#22312;&#36816;&#34892;&#65292;&#29289;&#29702;&#19978;&#23384;&#22312;&#65292;&#21644;&#20854;&#20182;&#24773;&#20917;&#12290;<span class="emphasis"><em>&#20855;&#20307;&#35831;&#21442;&#32771;Documentation/cpu-hotplug.txt&#12290;</em></span>
</p><pre class="programlisting">
static void __init boot_cpu_init(void)
{
	int cpu = smp_processor_id();
	/* Mark the boot cpu "present", "online" etc for SMP and UP case */
	cpu_set(cpu, cpu_online_map);
	cpu_set(cpu, cpu_present_map);
	cpu_set(cpu, cpu_possible_map);
}
</pre><p>	
</p><pre class="programlisting">
include/linux/cpumask.h
typedef struct cpumask { DECLARE_BITMAP(bits, NR_CPUS);}cpumask_t;

include/linux/types.h
#define DECLARE_BITMAP(name,bits) \
        unsigned long name[BITS_TO_LONGS(bits)]

include/linux/bitopts.h
#define BITS_PER_BYTE           8
#define BITS_TO_LONGS(nr)       DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))

include/linux/kernel.h
#define DIV_ROUND_UP(n,d) (((n) + (d) - 1) / (d))
</pre><p>
DIV_ROUND_UP&#20316;&#29992;&#26159;&#23558;n/d&#65292;&#38500;&#38750;&#25972;&#38500;&#65292;&#21542;&#21017;&#21521;&#19978;&#21462;&#25972;&#12290;&#32771;&#34385;sizeof(long)&#20026;4&#30340;&#24773;&#20917;&#65292;&#23637;&#24320;&#21518;&#30340;&#23450;&#20041;&#20026;&#65306;
</p><pre class="programlisting">
typedef struct cpumask 
{
 unsigned long bits[ceil[(NR_CPUS + 32 - 1)/32]] /* ceil&#24847;&#20026;&#21521;&#19978;&#21462;&#25972; */
}cpumask_t;
</pre><p>
NR_CPUS&#26159;&#19982;&#22810;&#22788;&#29702;&#30456;&#20851;&#30340;&#23439;&#23450;&#20041;&#65292;&#34920;&#31034;CPU&#30340;&#20010;&#25968;&#12290;&#22914;&#26524;&#23450;&#20041;&#20102;CONFIG_SMP&#37027;&#20040;&#21462;CONFIG_NR_CPUS&#65292;&#21542;&#21017;&#21462;1&#12290;
</p><pre class="programlisting">
include/linux/threads.h
#ifdef CONFIG_SMP
#define NR_CPUS         CONFIG_NR_CPUS
#else
#define NR_CPUS         1
#endif
</pre><p>
cpu_online_map&#21644;cpu_possible_map&#34987;&#23450;&#20041;&#22312;&#23545;&#24212;&#26550;&#26500;&#19979;&#30340;smp.c&#20013;&#12290;cpu_present_map&#21017;&#23450;&#20041;&#22312;&#36890;&#29992;&#30340;cpu.c&#20013;&#12290;
</p><pre class="programlisting">
arch/arm/kernel/smp.c
cpumask_t cpu_possible_map;
EXPORT_SYMBOL(cpu_possible_map);
cpumask_t cpu_online_map;
EXPORT_SYMBOL(cpu_online_map);

kernel/cpu.c
cpumask_t cpu_present_map __read_mostly;
EXPORT_SYMBOL(cpu_present_map);
</pre><p>
&#23545;&#36825;&#20123;CPU&#25513;&#30721;&#21464;&#37327;&#30340;&#24341;&#29992;&#38656;&#35201;&#36890;&#36807;&#23450;&#20041;&#22312;cpumask.h&#20013;&#30340;&#23439;&#65292;&#32780;&#19981;&#21487;&#30452;&#25509;&#25805;&#20316;&#12290;&#31995;&#32479;&#22312;include/linux/bitmap.h&#20013;&#23450;&#20041;&#20102;&#19968;&#20123;&#20301;&#25805;&#20316;&#20989;&#25968;&#65292;&#23427;&#20204;&#21516;&#26102;&#21253;&#21547;&#20102;&#29305;&#23450;&#31995;&#32479;&#26550;&#26500;&#30340;&#20301;&#25805;&#20316;&#20989;&#25968;&#65292;&#27604;&#22914;ARM&#30340;arch/arm/include/asm/bitops.h&#12290;
</p><pre class="programlisting">
include/linux/cpumask.h
#define cpu_set(cpu, dst) __cpu_set((cpu), &amp;(dst))
static inline void __cpu_set(int cpu, volatile cpumask_t *dstp)
{
        set_bit(cpu, dstp-&gt;bits);
}
</pre><p>
gcc&#30340;&#20869;&#24314;&#20989;&#25968; __builtin_constant_p &#29992;&#20110;&#21028;&#26029;&#19968;&#20010;&#20540;&#26159;&#21542;&#20026;&#32534;&#35793;&#26102;&#24120;&#25968;&#65292;&#22914;&#26524;&#21442;&#25968;EXP&#30340;&#20540;&#26159;&#24120;&#25968;&#65292;&#20989;&#25968;&#36820;&#22238;1&#65292;&#21542;&#21017;&#36820;&#22238; 0&#12290;&#36825;&#37324;&#23545;&#20301;&#25805;&#20316;&#37319;&#29992;&#21407;&#23376;&#25805;&#20316;&#65292;&#25152;&#20197;&#22312;&#25805;&#20316;&#21069;&#21518;&#38656;&#35201;&#20851;&#20013;&#26029;&#21644;&#24674;&#22797;&#20013;&#26029;&#26631;&#24535;&#20301;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/bitops.h
#define set_bit(nr,p)    ATOMIC_BITOP_LE(set_bit,nr,p)
#define ATOMIC_BITOP_LE(name,nr,p)              \
        (__builtin_constant_p(nr) ?             \
         ____atomic_##name(nr, p) :             \
         _##name##_le(nr,p))

static inline void ____atomic_set_bit(unsigned int bit, volatile unsigned long *p)
{
        unsigned long flags;
        unsigned long mask = 1UL &lt;&lt; (bit &amp; 31);

        p += bit &gt;&gt; 5;

        raw_local_irq_save(flags);
        *p |= mask;
        raw_local_irq_restore(flags);
}
</pre><p>
&#39318;&#20808;&#20351;&#29992;mrs&#25351;&#20196;&#23558;cpsr&#20445;&#23384;&#21040;x&#20013;&#65292;&#28982;&#21518;&#36890;&#36807;cpsid i&#20851;&#20013;&#26029;&#65292;cpsid&#21482;&#21487;&#20197;&#36816;&#34892;&#22312;&#38750;&#29992;&#25143;&#27169;&#24335;&#19979;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/irqflags.h
#define raw_local_irq_save(x)                                   \
        ({                                                      \
        __asm__ __volatile__(                                   \
        "mrs    %0, cpsr                @ local_irq_save\n"     \
        "cpsid  i"                                              \
        : "=r" (x) : : "memory", "cc");                         \
        })

#define raw_local_irq_restore(x)                                \
        __asm__ __volatile__(                                   \
        "msr    cpsr_c, %0              @ local_irq_restore\n"  \
        :                                                       \
        : "r" (x)                                               \
        : "memory", "cc")      
</pre><p>	
&#24674;&#22797;&#26631;&#24535;&#20301;&#65292;cpsr_c&#25351;CPSR&#20013;&#30340;control field&#65288;[7:0]&#65289;&#12290;&#30001;&#20110;F&#20301;&#65292;&#27169;&#24335;&#20301;M[3:0]&#21644;&#29366;&#24577;&#20301;T[4]&#19981;&#21464;&#65292;&#30456;&#24403;&#20110;&#21482;&#24674;&#22797;I&#20301;&#12290;
	</p>
</div>
<div class="sect2" title="9.2. &#20869;&#26680;&#29256;&#26412;&#20449;&#24687;"><div class="titlepage"><div><div><h3 class="title"><a name="idp80618452"></a>9.2. &#20869;&#26680;&#29256;&#26412;&#20449;&#24687;</h3></div></div></div>
	<p>
page_address_init&#22312;include/linux/mm.h&#20013;&#34987;&#23450;&#20041;&#20026;&#31354;&#20989;&#25968;&#12290;&#32039;&#25509;&#30528;&#23558;&#25171;&#21360;&#20986;&#20869;&#26680;&#30340;&#29256;&#26412;&#20449;&#24687;&#12290;
</p><pre class="programlisting">
	printk(KERN_NOTICE);
	printk(linux_banner);
</pre><p>
KERN_NOTICE&#26159;&#20869;&#26680;pinrk&#20989;&#25968;&#30340;&#19968;&#20010;&#20248;&#20808;&#32423;&#65292;&#23427;&#20204;&#34987;&#23450;&#20041;&#22312;kernel.h&#20013;&#12290;
</p><pre class="programlisting">
include/linux/kernel.h
#define KERN_EMERG      "&lt;0&gt;"   /* system is unusable                   */
#define KERN_ALERT      "&lt;1&gt;"   /* action must be taken immediately     */
#define KERN_CRIT       "&lt;2&gt;"   /* critical conditions                  */
#define KERN_ERR        "&lt;3&gt;"   /* error conditions                     */
#define KERN_WARNING    "&lt;4&gt;"   /* warning conditions                   */
#define KERN_NOTICE     "&lt;5&gt;"   /* normal but significant condition     */
#define KERN_INFO       "&lt;6&gt;"   /* informational                        */
#define KERN_DEBUG      "&lt;7&gt;"   /* debug-level messages                 */
</pre><p>
linux_banner&#21017;&#32473;&#20986;&#20102;&#19968;&#20123;&#20869;&#26680;&#21551;&#21160;&#26102;&#30340;&#20449;&#24687;&#12290;
</p><pre class="programlisting">
include/linux/utsrelease.h
#define UTS_RELEASE "2.6.28.6"

include/linux/compile.h
/* This file is auto generated, version 468 */
#define UTS_MACHINE "arm"
#define UTS_VERSION "#468 Fri Sep 16 14:19:20 CST 2011"
#define LINUX_COMPILE_TIME "14:19:20"
#define LINUX_COMPILE_BY "root"
#define LINUX_COMPILE_HOST "ubuntu"
#define LINUX_COMPILE_DOMAIN ""
#define LINUX_COMPILER "gcc version 4.2.2"

init/version.c
/* FIXED STRINGS! Don't touch! */
const char linux_banner[] =
        "Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
        LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";     
</pre><p>
utsrelease.h&#22312;&#20869;&#26680;&#30340;&#20027;Makefile&#33258;&#21160;&#29983;&#25104;&#65292;&#35268;&#21017;&#22914;&#19979;&#65292;&#26174;&#28982;tahiti&#26681;&#25454;KERNELRELEASE&#29983;&#25104;&#30340;&#65292;&#32780;KERNELRELEASE&#34987;&#23450;&#20041;&#20026;&#65306;KERNELRELEASE = $(shell cat include/config/kernel.release 2&gt; /dev/null)&#12290;&#25152;&#20197;&#26368;&#32456;&#30001;kernel.release&#25991;&#20214;&#25110;&#24471;&#65292;&#36825;&#20063;&#26159;&#23427;&#20316;&#20026;utsrelease.h&#20381;&#36182;&#30340;&#21407;&#22240;&#12290;
</p><pre class="programlisting">
uts_len := 64
define filechk_utsrelease.h
        if [ `echo -n "$(KERNELRELEASE)" | wc -c ` -gt $(uts_len) ]; then \
          echo '"$(KERNELRELEASE)" exceeds $(uts_len) characters' &gt;&amp;2;    \
          exit 1;                                                         \
        fi;                                                               \
        (echo \#define UTS_RELEASE \"$(KERNELRELEASE)\";)
endef
......
include/linux/utsrelease.h: include/config/kernel.release FORCE
        $(call filechk,utsrelease.h)
......  
</pre><p>	
compile.h&#22312;init/Makefile&#20013;&#23450;&#20041;&#20102;&#29983;&#25104;&#35268;&#21017;&#65292;&#36825;&#20123;&#23439;&#22343;&#26159;&#36890;&#36807;&#33050;&#26412;scripts/mkcompile_h&#26816;&#27979;&#21644;&#29983;&#25104;&#30340;&#12290;
</p><pre class="programlisting">
include/linux/compile.h: FORCE
        @$($(quiet)chk_compile.h)
        $(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkcompile_h $@ \
        "$(UTS_MACHINE)" "$(CONFIG_SMP)" "$(CONFIG_PREEMPT)" "$(CC) $(KBUILD_CFLAGS)"
</pre><p>
&#23427;&#30340;&#36755;&#20986;&#31867;&#20284;&#20110;&#22914;&#19979;&#20449;&#24687;&#12290;&#36825;&#20123;&#20449;&#24687;&#25351;&#26126;&#20102;&#20869;&#26680;&#29256;&#26412;&#65292;&#32534;&#35793;&#26102;&#38388;&#21644;&#32534;&#35793;&#29615;&#22659;&#12290;
</p><pre class="programlisting">
Linux version 2.6.28.6 (root@ubuntu) (gcc version 4.2.2) #468 Fri Sep 16 14:19:20 CST 2011
</pre><p>
</p>
</div>
<div class="sect2" title="9.3. &#20869;&#23384;&#23631;&#38556;"><div class="titlepage"><div><div><h3 class="title"><a name="idp80624164"></a>9.3. &#20869;&#23384;&#23631;&#38556;</h3></div></div></div>
<p>
&#20869;&#23384;&#23631;&#38556;&#20445;&#35777;&#39640;&#32423;&#35821;&#35328;&#65292;&#27604;&#22914;C&#35821;&#35328;&#30340;&#32534;&#35793;&#22120;&#22312;&#20248;&#21270;&#29983;&#25104;&#30340;&#20195;&#30721;&#26102;&#33021;&#22815;&#20445;&#35777;&#24635;&#26159;&#20351;&#29992;&#20869;&#23384;&#20013;&#30340;&#20540;&#65292;&#32780;&#19981;&#26159;D Cache&#32531;&#20914;&#21306;&#25110;&#32773;&#23492;&#23384;&#22120;&#20013;&#30340;&#20540;&#12290;&#25442;&#21477;&#35805;&#35828;&#65292;&#25152;&#26377;&#22312;&#35774;&#32622;&#20869;&#23384;&#23631;&#38556;&#21069;&#21457;&#36215;&#30340;&#20869;&#23384;&#35775;&#38382;&#65292;&#24517;&#39035;&#22312;&#35774;&#32622;&#20869;&#23384;&#23631;&#38556;&#20043;&#21518;&#21457;&#36215;&#30340;&#20869;&#23384;&#35775;&#38382;&#20043;&#21069;&#23436;&#25104;&#65292;&#24182;&#19988;&#20043;&#21518;&#30340;&#35775;&#38382;&#34987;&#20445;&#35777;&#26159;&#20174;&#20869;&#23384;&#32780;&#26469;&#12290;&#20869;&#23384;&#23631;&#38556;&#30340;&#26412;&#36136;&#26159;&#20445;&#35777;&#20102;&#25351;&#20196;&#25353;&#29305;&#23450;&#30340;&#39034;&#24207;&#25191;&#34892;&#65292;&#32780;&#38750;&#32534;&#35793;&#22120;&#20248;&#21270;&#36807;&#30340;&#39034;&#24207;&#25191;&#34892;&#12290;&#20869;&#23384;&#23631;&#38556;&#30001;&#19968;&#20010;&#21517;&#20026;barrier()&#30340;&#23439;&#23450;&#20041;&#65306;
</p><pre class="programlisting">
include/linux/compiler-gcc.h
#define barrier() __asm__ __volatile__("": : :"memory")
</pre><p>	
&#35201;&#24443;&#24213;&#29702;&#35299;barrier()&#30340;&#20316;&#29992;&#65292;&#38656;&#35201;&#39318;&#20808;&#29702;&#35299;&#20869;&#23884;&#27719;&#32534;&#12290;&#23383;&#31526;&#20018;"memory"&#21521;GCC&#22768;&#26126;&#65306;"&#22312;&#36825;&#37324;&#65292;&#20869;&#23384;&#21457;&#29983;&#20102;&#65292;&#25110;&#21487;&#33021;&#21457;&#29983;&#20102;&#25913;&#21464;"&#12290;&#25509;&#19979;&#26469;&#30340;&#22312;&#32534;&#35793;&#22120;&#38656;&#35201;&#26576;&#20010;&#20869;&#23384;&#20013;&#30340;&#25968;&#25454;&#26102;&#65292;&#23427;&#23558;&#20174;&#20869;&#23384;&#21462;&#24471;&#65292;&#32780;&#19981;&#26159;&#23492;&#23384;&#22120;&#25110;&#32773;&#39640;&#36895;&#32531;&#23384;&#12290;&#19968;&#20010;&#23454;&#38469;&#30340;&#20363;&#23376;&#22914;&#19979;&#25152;&#31034;&#65306;
</p><pre class="programlisting">
#define barrier() __asm__ __volatile__("": : :"memory")
int g_test = 0;
int main()
{
        int *tmp = &amp;g_test;
        *tmp = 100;
     // barrier();
        if(*tmp == 100)
                return 0;

        return 1;
}
</pre><p>
&#32534;&#35793;&#21629;&#20196;&#22914;&#19979;&#65292;&#20026;&#20102;&#24471;&#21040;&#38388;&#25509;&#30340;&#20195;&#30721;&#65292;&#21442;&#25968;&#20013;&#21152;&#19978;&#20102;-O2&#20248;&#21270;&#36873;&#39033;&#12290;
</p><pre class="programlisting">
arm-linux-gcc test.c -o test -O2
</pre><p>	
&#39318;&#20808;&#32534;&#35793;&#27809;&#26377;&#20869;&#23384;&#23631;&#38556;&#23439;&#30340;&#20195;&#30721;&#65292;&#24182;&#21453;&#27719;&#32534;&#24471;&#21040;main&#20989;&#25968;&#23545;&#24212;&#30340;&#27719;&#32534;&#25351;&#20196;&#65306;
</p><pre class="programlisting">
00008334 &lt;main&gt;:
    8334:       e59f300c        ldr     r3, [pc, #12]   ; 8348 &lt;main+0x14&gt;
    8338:       e3a02064        mov     r2, #100        ; 0x64
    833c:       e3a00000        mov     r0, #0  ; 0x0
    8340:       e5832000        str     r2, [r3]
    8344:       e12fff1e        bx      lr
    8348:       000104fc        .word   0x000104fc
</pre><p>
&#36825;&#37324;&#25214;&#19981;&#21040;*tmp == 100&#23545;&#24212;&#30340;&#27719;&#32534;&#25351;&#20196;&#65292;&#26174;&#28982;&#32534;&#35793;&#22120;&#35748;&#20026;&#36825;&#21477;&#35805;&#26159;&#22810;&#20313;&#30340;&#65292;&#22240;&#20026;&#20174;*tmp = 100&#36825;&#21477;&#35805;&#24320;&#22987;&#65292;*tmp&#30340;&#20540;&#27809;&#26377;&#34987;&#20219;&#20309;&#35821;&#21477;&#25913;&#21464;&#36807;&#65292;&#25152;&#20197;&#23427;&#23581;&#35797;&#20102;&#20248;&#21270;&#12290;&#25509;&#19979;&#26469;&#25171;&#24320;barrier()&#12290;
</p><pre class="programlisting">
00008334 &lt;main&gt;:
    8334:       e59f3014        ldr     r3, [pc, #20]   ; 8350 &lt;main+0x1c&gt;
    8338:       e3a02064        mov     r2, #100        ; 0x64
    833c:       e5832000        str     r2, [r3]
    8340:       e5930000        ldr     r0, [r3]
    8344:       e0500002        subs    r0, r0, r2
    8348:       13a00001        movne   r0, #1  ; 0x1
    834c:       e12fff1e        bx      lr
    8350:       00010504        .word   0x00010504
</pre><p>
&#21487;&#20197;&#30475;&#21040;subs&#21644;movne&#25351;&#20196;&#65292;&#25152;&#20197;&#30830;&#23454;&#25191;&#34892;&#20102;&#27604;&#36739;&#25805;&#20316;&#12290;&#32771;&#34385;&#20160;&#20040;&#26102;&#20505;g_test&#30340;&#20540;&#20250;&#34987;&#24708;&#24708;&#25913;&#21464;&#21602;&#65311;&#24403;g_test&#25351;&#21521;&#30340;&#26159;&#20844;&#29992;&#20869;&#23384;&#26159;&#65292;&#27604;&#22914;mmap&#65292;&#25110;&#32773;&#26159;I/O&#22320;&#22336;&#65292;&#22810;&#20010;&#32447;&#31243;&#30340;&#20844;&#29992;&#21464;&#37327;&#31561;&#12290;&#21482;&#35201;&#36825;&#20010;&#21464;&#37327;&#34987;&#20854;&#20182;&#30340;&#38750;&#36816;&#34892;&#22312;&#35813;CPU&#19978;&#30340;&#36827;&#31243;/&#32447;&#31243;&#25351;&#20196;&#25913;&#21464;&#30340;&#21487;&#33021;&#37117;&#20250;&#21457;&#29983;&#36825;&#31181;&#24773;&#20917;&#12290;
</p>
</div>
<div class="sect2" title="9.4. &#20869;&#26680;&#25250;&#21344;"><div class="titlepage"><div><div><h3 class="title"><a name="idp80629220"></a>9.4. &#20869;&#26680;&#25250;&#21344;</h3></div></div></div>
<p>
&#19982;&#20854;&#20182;&#22823;&#37096;&#20998;Unix&#21464;&#20307;&#21644;&#20854;&#20182;&#22823;&#37096;&#20998;&#30340;&#25805;&#20316;&#31995;&#32479;&#19981;&#21516;&#65292; Linux&#23436;&#25972;&#22320;&#25903;&#25345;&#20869;&#26680;&#25250;&#21344;&#12290;&#22312;&#19981;&#25903;&#25345;&#20869;&#26680;&#25250;&#21344;&#30340;&#20869;&#26680;&#20013;&#65292;&#20869;&#26680;&#20195;&#30721;&#21487;&#20197;&#19968;&#30452;&#25191;&#34892;&#30452;&#21040;&#23427;&#23436;&#25104;&#20026;&#27490;&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;&#35843;&#24230;&#31243;&#24207;&#27809;&#26377;&#21150;&#27861;&#22312;&#19968;&#20010;&#20869;&#26680;&#32423;&#30340;&#20219;&#21153;&#27491;&#22312;&#25191;&#34892;&#30340;&#26102;&#20505;&#37325;&#26032;&#35843;&#24230;&#8212;&#8212;&#20869;&#26680;&#20013;&#30340;&#21508;&#20219;&#21153;&#26159;&#21327;&#20316;&#26041;&#24335;&#35843;&#24230;&#30340;&#65292;&#19981;&#20855;&#22791;&#25250;&#21344;&#24615;&#12290;&#22312;2.6&#29256;&#30340;&#20869;&#26680;&#20013;&#65292;&#20869;&#26680;&#24341;&#20154;&#20102;&#25250;&#21344;&#33021;&#21147;&#65307;&#29616;&#22312;&#65292;&#21482;&#35201;&#37325;&#26032;&#35843;&#24230;&#26159;&#23433;&#20840;&#30340;&#65292;&#37027;&#20040;&#20869;&#26680;&#23601;&#21487;&#20197;&#22312;&#20219;&#20309;&#26102;&#38388;&#25250;&#21344;&#27491;&#22312;&#25191;&#34892;&#30340;&#20219;&#21153;&#12290;&#37027;&#20040;&#65292;&#20160;&#20040;&#26102;&#20505;&#37325;&#26032;&#35843;&#24230;&#25165;&#26159;&#23433;&#20840;&#30340;&#21602;&#65311;&#21482;&#35201;&#27809;&#26377;&#25345;&#26377;&#38145;&#65292;&#20869;&#26680;&#23601;&#21487;&#20197;&#36827;&#34892;&#25250;&#21344;&#12290;&#38145;&#26159;&#38750;&#25250;&#21344;&#21306;&#22495;&#30340;&#26631;&#24535;&#12290;&#30001;&#20110;&#20869;&#26680;&#26159;&#25903;&#25345;SMP&#30340;&#65292;&#25152;&#20197;&#65292;&#22914;&#26524;&#27809;&#26377;&#25345;&#26377;&#38145;&#65292;&#37027;&#20040;&#27491;&#22312;&#25191;&#34892;&#30340;&#20195;&#30721;&#23601;&#26159;&#21487;&#37325;&#26032;&#23548;&#20837;&#30340;&#65292;&#20063;&#23601;&#26159;&#21487;&#20197;&#25250;&#21344;&#30340;&#12290;
</p>
<p>
&#20026;&#20102;&#25903;&#25345;&#20869;&#26680;&#25250;&#21344;&#65292;&#27599;&#20010;&#36827;&#31243;&#30340;&#25968;&#25454;&#32467;&#26500;thread_info&#20013;&#24341;&#20837;&#20102;preempt_count&#35745;&#25968;&#22120;&#12290;&#35813;&#35745;&#25968;&#22120;&#21021;&#22987;&#20540;&#36890;&#24120;&#20026;0&#65292;&#27599;&#24403;&#20351;&#29992;&#38145;&#30340;&#26102;&#20505;&#25968;&#20540;&#21152;1&#65292;&#37322;&#25918;&#38145;&#30340;&#26102;&#20505;&#25968;&#20540;&#20943;1&#12290;&#24403;&#25968;&#20540;&#20026;0&#30340;&#26102;&#20505;&#65292;&#20869;&#26680;&#23601;&#21487;&#25191;&#34892;&#25250;&#21344;&#12290;&#20174;&#20013;&#26029;&#36820;&#22238;&#20869;&#26680;&#31354;&#38388;&#30340;&#26102;&#20505;&#65292;&#20869;&#26680;&#20250;&#26816;&#26597;need_resched&#21644;preempt_count&#30340;&#20540;&#12290;&#22914;&#26524;need_resched&#34987;&#35774;&#32622;&#65292;&#24182;&#19988;&#24403;&#21069;&#36827;&#31243;preempt_count&#20026;0&#30340;&#35805;&#65292;&#36825;&#35828;&#26126;&#26377;&#19968;&#20010;&#26356;&#20026;&#37325;&#35201;&#30340;&#20219;&#21153;&#38656;&#35201;&#25191;&#34892;&#24182;&#19988;&#21487;&#20197;&#23433;&#20840;&#22320;&#25250;&#21344;&#65292;&#27492;&#26102;&#65292;&#35843;&#24230;&#31243;&#24207;&#23601;&#20250;&#35843;&#24230;(&#25250;&#21344;&#24403;&#21069;&#36827;&#31243;)&#12290;&#22914;&#26524;preempt_count&#19981;&#20026;0&#65292;&#35828;&#26126;&#24403;&#21069;&#20219;&#21153;&#25345;&#26377;&#38145;&#65292;&#25152;&#20197;&#25250;&#21344;&#26159;&#19981;&#23433;&#20840;&#30340;&#12290;&#36825;&#26102;&#65292;&#23601;&#20250;&#20687;&#36890;&#24120;&#37027;&#26679;&#30452;&#25509;&#20174;&#20013;&#26029;&#36820;&#22238;&#24403;&#21069;&#25191;&#34892;&#36827;&#31243;&#12290;&#22914;&#26524;&#24403;&#21069;&#36827;&#31243;&#25152;&#25345;&#26377;&#30340;&#25152;&#26377;&#30340;&#38145;&#37117;&#34987;&#37322;&#25918;&#20102;&#12290;&#37027;&#20040;preempt_count&#23601;&#20250;&#37325;&#26032;&#20026;0&#12290;&#27492;&#26102;&#65292;&#37322;&#25918;&#38145;&#30340;&#20195;&#30721;&#20250;&#26816;&#26597;need_resched&#26159;&#21542;&#34987;&#35774;&#32622;&#12290;&#22914;&#26524;&#26159;&#30340;&#35805;&#65292;&#23601;&#20250;&#35843;&#29992;&#35843;&#24230;&#31243;&#24207;&#12290;&#26377;&#20123;&#20869;&#26680;&#20195;&#30721;&#38656;&#35201;&#20801;&#35768;&#25110;&#31105;&#27490;&#20869;&#26680;&#25250;&#21344;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/thread_info.h
#define INIT_THREAD_INFO(tsk)                                           \
{                                                                       \
        .task           = &amp;tsk,                                         \
        .exec_domain    = &amp;default_exec_domain,                         \
        .flags          = 0,                                            \
        .preempt_count  = 1,                                            \
        .addr_limit     = KERNEL_DS,                                    \
        .cpu_domain     = domain_val(DOMAIN_USER, DOMAIN_MANAGER) |     \
                          domain_val(DOMAIN_KERNEL, DOMAIN_MANAGER) |   \
                          domain_val(DOMAIN_IO, DOMAIN_CLIENT),         \
        .restart_block  = {                                             \
                .fn     = do_no_restart_syscall,                        \
        },                                                              \
}
......
struct task_struct init_task = INIT_TASK(init_task);
</pre><p>
init_task&#20195;&#34920;&#30340;0&#21495;&#36827;&#31243;&#27604;&#36739;&#29305;&#27530;&#65292;&#23427;&#30340;preempt_count&#21021;&#22987;&#20540;&#20026;1&#65292;&#20063;&#21363;&#23427;&#40664;&#35748;&#26159;&#19981;&#21487;&#25250;&#21344;&#30340;&#30452;&#21040;&#23427;&#33258;&#36523;&#23558;preempt_count&#32622;&#20026;0&#12290;&#20869;&#26680;&#25250;&#21344;&#36890;&#36807;&#22312;.config&#20013;&#37197;&#32622;CONFIG_PREEMPT&#20351;&#33021;&#12290;preempt_count&#30340;&#25805;&#20316;&#36890;&#36807;&#20197;&#19979;&#23439;&#23450;&#20041;&#36827;&#34892;&#65306;
</p><pre class="programlisting">
include/linux/preempt.h

# define add_preempt_count(val) do { preempt_count() += (val); } while (0)
# define sub_preempt_count(val) do { preempt_count() -= (val); } while (0)
#define inc_preempt_count() add_preempt_count(1)
#define dec_preempt_count() sub_preempt_count(1)
#define preempt_count() (current_thread_info()-&gt;preempt_count)

#ifdef CONFIG_PREEMPT
#define preempt_disable() \
do { \
        inc_preempt_count(); \
        barrier(); \
} while (0)
</pre><p>
preempt_disable&#30340;&#23454;&#29616;&#39318;&#36890;&#36807;inc_preempt_count&#23558;&#36827;&#31243;&#30340;preempt_count&#22686;&#21152;1&#65292;&#28982;&#21518;&#20351;&#29992;&#20869;&#23384;&#23631;&#38556;&#30830;&#20445;&#25805;&#20316;&#23436;&#25104;&#12290;
</p><pre class="programlisting">
#define preempt_enable_no_resched() \
do { \
        barrier(); \
        dec_preempt_count(); \
} while (0)

#define preempt_check_resched() \
do { \
        if (unlikely(test_thread_flag(TIF_NEED_RESCHED))) \
                preempt_schedule(); \
} while (0)

#define preempt_enable() \
do { \
        preempt_enable_no_resched(); \
        barrier(); \
        preempt_check_resched(); \
} while (0)
#else
.....
</pre><p>
preempt_enable&#39318;&#20808;&#36890;&#36807;&#20869;&#23384;&#23631;&#38556;&#30830;&#20445;&#24403;&#21069;&#25805;&#20316;&#23436;&#25104;&#65292;&#28982;&#21518;&#36890;&#36807;dec_preempt_count&#23558;&#36827;&#31243;&#30340;preempt_count&#20943;&#21435;1&#65292;&#25509;&#30528;&#26681;&#25454;TIF_NEED_RESCHED&#26631;&#24535;&#20301;&#20915;&#23450;&#26159;&#21542;&#25191;&#34892;preempt_schedule&#20174;&#32780;&#35302;&#21457;&#35843;&#24230;&#20989;&#25968;schedule&#30340;&#25191;&#34892;&#12290;
</p>
<p>
&#22914;&#26524;&#20869;&#26680;&#20013;&#30340;&#36827;&#31243;&#34987;&#38459;&#22622;&#20102;&#65292;&#25110;&#23427;&#26174;&#24335;&#22320;&#35843;&#29992;&#20102;schedule()&#65292;&#20869;&#26680;&#25250;&#21344;&#20063;&#20250;&#26174;&#24335;&#22320;&#21457;&#29983;&#12290;&#36825;&#31181;&#24418;&#24335;&#30340;&#20869;&#26680;&#20195;&#30721;&#20174;&#26469;&#37117;&#26159;&#21463;&#25903;&#25345;&#30340;&#65292;&#22240;&#20026;&#26681;&#26412;&#26080;&#38656;&#39069;&#22806;&#30340;&#36923;&#36753;&#26469;&#20445;&#35777;&#20869;&#26680;&#21487;&#20197;&#23433;&#20840;&#22320;&#21457;&#29983;&#34987;&#25250;&#21344;&#12290;&#22914;&#26524;&#20195;&#30721;&#26174;&#24335;&#30340;&#35843;&#29992;&#20102;schedule()&#65292;&#37027;&#20040;&#23427;&#24212;&#35813;&#28165;&#26970;&#33258;&#24049;&#26159;&#21487;&#20197;&#23433;&#20840;&#22320;&#34987;&#25250;&#21344;&#30340;&#12290;
</p>	
<p>
&#20869;&#26680;&#25250;&#21344;&#21457;&#29983;&#22312;:
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">(1) &#24403;"&#20174;&#20013;&#26029;&#22788;&#29702;&#31243;&#24207;"&#27491;&#22312;&#25191;&#34892;&#65292;&#19988;&#36820;&#22238;&#20869;&#26680;&#31354;&#38388;&#20043;&#21069;</li><li class="listitem">(2) &#20869;&#26680;&#20195;&#30721;&#20877;&#19968;&#27425;&#20855;&#26377;&#21487;&#25250;&#21344;&#24615;&#30340;&#26102;&#20505;</li><li class="listitem">(3) &#22914;&#26524;&#20869;&#26680;&#20013;&#30340;&#20219;&#21153;&#26174;&#24335;&#30340;&#35843;&#29992;schedule()</li><li class="listitem">(4) &#22914;&#26524;&#20869;&#26680;&#20013;&#30340;&#20219;&#21153;&#38459;&#22622;(&#36825;&#21516;&#26679;&#20063;&#20250;&#23548;&#33268;&#35843;&#29992;schedule())</li></ul></div><p>
</p>	
</div>
<div class="sect2" title="9.5. printk"><div class="titlepage"><div><div><h3 class="title"><a name="idp80637180"></a>9.5. printk</h3></div></div></div>
<p>
&#19968;&#20010;&#22855;&#24618;&#30340;&#20107;&#23454;&#26159;printk&#26159;&#22914;&#20309;&#23558;&#20449;&#24687;&#25171;&#21360;&#20986;&#26469;&#30340;&#65292;&#27492;&#26102;&#19968;&#20123;&#22522;&#26412;&#30340;&#21021;&#22987;&#21270;&#36824;&#27809;&#26377;&#23436;&#25104;&#12290;&#23427;&#34987;&#23450;&#20041;&#22312;kernel/printk.c&#20013;&#65306;
</p><pre class="programlisting">
asmlinkage int printk(const char *fmt, ...)
{
	va_list args;
	int r;
	
	va_start(args, fmt);
	r = vprintk(fmt, args);
	va_end(args);
	
	return r;
}
</pre><p>
&#19979;&#38754;&#23601;&#25509;&#30528;&#30475;vprintk&#20989;&#25968;&#30340;&#22788;&#29702;&#27969;&#31243;&#65292;vprintk&#23454;&#29616;printk&#30340;&#20027;&#35201;&#25805;&#20316;&#12290;&#23427;&#29992;&#21040;&#20102;&#20004;&#20010;&#32531;&#20914;&#21306;&#65292;&#24182;&#26368;&#32456;&#35843;&#29992;&#32456;&#31471;&#39537;&#21160;&#25171;&#21360;&#20986;&#20449;&#24687;&#12290;
</p><pre class="programlisting">
asmlinkage int vprintk(const char *fmt, va_list args)
{
	int printed_len = 0;
	int current_log_level = default_message_loglevel;
	unsigned long flags;
	int this_cpu;
	char *p;

	boot_delay_msec();

	preempt_disable();
	/* This stops the holder of console_sem just where we want him */
	raw_local_irq_save(flags);
	this_cpu = smp_processor_id();
</pre><p>
&#39318;&#20808;&#35774;&#32622;&#24403;&#21069;&#26085;&#24535;&#32423;&#21035;&#20026;default_message_loglevel&#65292;&#25152;&#26377;&#20851;&#20110;&#20869;&#26680;&#26085;&#24535;&#32423;&#21035;&#30340;&#35774;&#23450;&#22343;&#20301;&#20110;kernel.h&#20013;&#12290;boot_delay_msec&#21482;&#26377;&#37197;&#32622;&#20102;CONFIG_BOOT_PRINTK_DELAY&#25165;&#36215;&#20316;&#29992;&#65292;&#23427;&#23581;&#35797;&#22312;&#20869;&#26680;&#25171;&#21360;&#19968;&#26465;&#20449;&#24687;&#21518;&#31561;&#24453;&#19968;&#27573;&#26102;&#38388;&#12290;preempt_disable&#31105;&#27490;&#20869;&#26680;&#25250;&#21344;&#12290;raw_local_irq_save&#31105;&#20013;&#26029;&#65292;&#26159;&#20026;&#20102;&#20351;console_sem&#20449;&#21495;&#37327;&#30340;&#25345;&#26377;&#32773;&#33021;&#22815;&#22312;&#25105;&#20204;&#24076;&#26395;&#23427;&#20572;&#27490;&#30340;&#22320;&#26041;&#20572;&#27490;&#12290;this_cpu&#33719;&#21462;&#24403;&#21069;CPU&#30340;&#32534;&#21495;&#65292;&#23427;&#29992;&#26469;&#26816;&#27979;printk&#26159;&#21542;&#20986;&#29616;&#20102;&#23884;&#22871;&#12290;
</p><pre class="programlisting">
include/linux/kernel.h
#define console_loglevel (console_printk[0])
#define default_message_loglevel (console_printk[1])
#define minimum_console_loglevel (console_printk[2])
#define default_console_loglevel (console_printk[3])

kernel/printk.c
int console_printk[4] = {
	DEFAULT_CONSOLE_LOGLEVEL,	/* console_loglevel */
	DEFAULT_MESSAGE_LOGLEVEL,	/* default_message_loglevel */
	MINIMUM_CONSOLE_LOGLEVEL,	/* minimum_console_loglevel */
	DEFAULT_CONSOLE_LOGLEVEL,	/* default_console_loglevel */
};
</pre><p>

</p><pre class="programlisting">
	/*
	 * Ouch, printk recursed into itself!
	 */
	if (unlikely(printk_cpu == this_cpu)) {
		/*
		 * If a crash is occurring during printk() on this CPU,
		 * then try to get the crash message out but make sure
		 * we can't deadlock. Otherwise just return to avoid the
		 * recursion and return - but flag the recursion so that
		 * it can be printed at the next appropriate moment:
		 */
		if (!oops_in_progress) {
			recursion_bug = 1;
			goto out_restore_irqs;
		}
		zap_locks();
	}

	lockdep_off();
	spin_lock(&amp;logbuf_lock);
	printk_cpu = this_cpu;	
</pre><p>
printk_cpu&#35760;&#24405;&#20102;&#24403;&#21069;&#25191;&#34892;vprintk&#30340;CPU&#30340;&#32534;&#21495;&#12290;oops_in_progress&#21482;&#26377;&#22312;panic(), BUG() &#25110; die() &#35843;&#29992;&#20013;&#25165;&#20250;&#34987;&#32622;1&#12290;&#22914;&#26524;&#21457;&#29616;&#23884;&#22871;&#35843;&#29992;&#65292;&#37027;&#20040;&#32622;recursion_bug&#20026;1&#65292;&#28982;&#21518;&#20570;&#24674;&#22797;&#22788;&#29702;&#21518;&#30452;&#25509;&#36864;&#20986;&#12290;&#25152;&#20197;&#23884;&#22871;&#35843;&#29992;&#30340;&#38169;&#35823;&#20449;&#24687;&#21482;&#26377;&#22312;&#19979;&#27425;&#35843;&#29992;printk&#26102;&#25165;&#33021;&#22788;&#29702;&#12290;zap_locks&#21482;&#26377;&#22312;oops&#22788;&#29702;&#26102;&#25165;&#20250;&#34987;&#35843;&#29992;&#65292;&#27492;&#26102;&#36825;&#20010;CPU&#23849;&#28291;&#65292;10&#31186;1&#27425;&#21021;&#22987;&#21270;&#38145;logbuf_lock&#21644;console_sem&#65292;&#20197;&#30830;&#20445;&#19981;&#20250;&#27515;&#38145;&#65292;&#30041;&#26102;&#38388;&#32473;&#25511;&#21046;&#21488;&#25171;&#21360;&#23436;&#20840;&#30340;oops&#20449;&#24687;&#12290;&#25509;&#19979;&#26469;&#38145;&#20303;logbuf_lock&#65292;&#23427;&#21516;&#26102;&#20445;&#35777;&#23545;log_buf&#21644;printk_buf&#30340;&#20114;&#26021;&#25805;&#20316;&#12290;&#25509;&#30528;&#35760;&#24405;&#24403;&#21069;&#30340;CPU&#32534;&#21495;&#12290;
</p><pre class="programlisting">
static void zap_locks(void)
{
	static unsigned long oops_timestamp;

	if (time_after_eq(jiffies, oops_timestamp) &amp;&amp;
			!time_after(jiffies, oops_timestamp + 30 * HZ))
		return;

	oops_timestamp = jiffies;

	/* If a crash is occurring, make sure we can't deadlock */
	spin_lock_init(&amp;logbuf_lock);
	/* And make sure that we print immediately */
	init_MUTEX(&amp;console_sem);
}
</pre><p>
&#22914;&#26524;&#21457;&#29983;&#20102;&#23884;&#22871;&#35843;&#29992;&#65292;&#37027;&#20040;recursion_bug&#28165;&#38646;&#65292;&#19982;&#27492;&#21516;&#26102;&#23558;recursion_bug_msg&#20449;&#24687;&#25918;&#20837;printk_buf&#12290;&#27880;&#24847;&#23884;&#22871;&#35843;&#29992;&#26159;&#21457;&#29983;&#22312;&#19978;&#19968;&#27425;&#65292;&#32780;&#38750;&#26412;&#27425;&#12290;
</p><pre class="programlisting">
static const char recursion_bug_msg [] =
		KERN_CRIT "BUG: recent printk recursion!\n";		
......
	if (recursion_bug) {
		recursion_bug = 0;
		strcpy(printk_buf, recursion_bug_msg);
		printed_len = sizeof(recursion_bug_msg);
	}
</pre><p>
&#23558;&#35201;&#36755;&#20986;&#30340;&#23383;&#31526;&#20018;&#25353;&#29031;fmt&#20013;&#30340;&#26684;&#24335;&#32534;&#25490;&#22909;&#65292;&#25918;&#20837;printk_buf&#20013;&#65292;&#24182;&#36820;&#22238;&#24212;&#35813;&#36755;&#20986;&#30340;&#23383;&#31526;&#20010;&#25968;&#12290;
</p><pre class="programlisting">
	/* Emit the output into the temporary buffer */
	printed_len += vscnprintf(printk_buf + printed_len,
				  sizeof(printk_buf) - printed_len, fmt, args);
</pre><p>
&#25335;&#36125;printk_buf&#25968;&#25454;&#21040;&#29615;&#24418;&#32531;&#20914;&#21306;&#20013;&#65292;&#22914;&#26524;&#35843;&#29992;&#32773;&#27809;&#26377;&#25552;&#20379;&#21512;&#36866;&#30340;&#26085;&#24535;&#32423;&#21035;&#65292;&#21017;&#25554;&#20837;&#40664;&#35748;&#32423;&#21035;&#12290;&#25335;&#36125;&#30340;&#36807;&#31243;&#30001;&#20989;&#25968;emit_log_char&#23454;&#29616;&#65292;&#27599;&#27425;&#25335;&#36125;&#19968;&#20010;&#23383;&#33410;&#12290;&#21478;&#22806;&#22914;&#26524;&#37197;&#32622;&#20102;CONFIG_PRINTK_TIME&#65292;printk_time&#23558;&#34987;&#35774;&#32622;&#20026;1&#65292;&#23558;&#22312;&#27599;&#26465;&#20449;&#24687;&#21069;&#21152;&#19978;&#24403;&#21069;&#26102;&#38388;&#12290;
</p><pre class="programlisting">
	for (p = printk_buf; *p; p++) {
		if (new_text_line) {
			/* If a token, set current_log_level and skip over */
			if (p[0] == '&lt;' &amp;&amp; p[1] &gt;= '0' &amp;&amp; p[1] &lt;= '7' &amp;&amp;
			    p[2] == '&gt;') {
				current_log_level = p[1] - '0';
				p += 3;
				printed_len -= 3;
			}

			/* Always output the token */
			emit_log_char('&lt;');
			emit_log_char(current_log_level + '0');
			emit_log_char('&gt;');
			printed_len += 3;
			new_text_line = 0;

			if (printk_time) {
				/* Follow the token with the time */
				......
			}

			if (!*p)
				break;
		}
		......
	}
</pre><p>
&#30495;&#27491;&#30340;&#25171;&#21360;&#22312;release_console_sem&#20013;&#35843;&#29992;&#23454;&#38469;&#30340;&#20018;&#21475;&#39537;&#21160;&#36827;&#34892;&#65292;&#20294;&#26159;&#23545;&#20018;&#21475;&#39537;&#21160;&#30340;&#25805;&#20316;&#38656;&#35201;&#33719;&#21462;console_sem&#12290;acquire_console_semaphore_for_printk&#23601;&#26159;&#33719;&#21462;&#20449;&#21495;&#37327;&#30340;&#25805;&#20316;&#12290;
</p><pre class="programlisting">
	if (acquire_console_semaphore_for_printk(this_cpu))
		release_console_sem();
</pre><p>
acquire_console_semaphore_for_printk&#20989;&#25968;&#24517;&#39035;&#22312;&#38145;&#23450;logbuf_lock&#24182;&#19988;&#20851;&#20013;&#26029;&#26102;&#25165;&#21487;&#35843;&#29992;&#12290;&#22914;&#26524;&#33719;&#21462;&#25104;&#21151;&#24517;&#39035;&#35774;&#32622;console_locked&#20026;1&#65292;console_may_schedule&#21017;&#34987;&#28165;&#38646;&#12290;can_use_console&#29992;&#26469;&#21028;&#26029;&#20018;&#21475;&#39537;&#21160;&#26159;&#21542;&#24050;&#32463;&#34987;&#27880;&#20876;&#20837;&#20869;&#26680;&#12290;&#26080;&#35770;&#33719;&#21462;&#22833;&#36133;&#36824;&#26159;&#25104;&#21151;&#37117;&#23558;&#37322;&#25918;spin_unlock&#33258;&#26059;&#38145;&#12290;&#27492;&#26102;CPU&#20381;&#28982;&#22788;&#20110;&#20851;&#20013;&#26029;&#29615;&#22659;&#65292;&#36825;&#26159;&#30001;&#20110;vprintk&#23558;&#22788;&#29702;&#20013;&#26029;&#30340;&#24674;&#22797;&#12290;
</p><pre class="programlisting">
int try_acquire_console_sem(void)
{
	if (down_trylock(&amp;console_sem))
		return -1;
	console_locked = 1;
	console_may_schedule = 0;
	return 0;
}
......
static int acquire_console_semaphore_for_printk(unsigned int cpu)
{
	int retval = 0;

	if (!try_acquire_console_sem()) {
		retval = 1;

		/*
		 * If we can't use the console, we need to release
		 * the console semaphore by hand to avoid flushing
		 * the buffer. We need to hold the console semaphore
		 * in order to do this test safely.
		 */
		if (!can_use_console(cpu)) {
			console_locked = 0;
			up(&amp;console_sem);
			retval = 0;
		}
	}
	printk_cpu = UINT_MAX;
	spin_unlock(&amp;logbuf_lock);
	return retval;
}
</pre><p>
</p><pre class="programlisting">
void release_console_sem(void)
{
	unsigned long flags;
	unsigned _con_start, _log_end;
	unsigned wake_klogd = 0;

	if (console_suspended) {
		up(&amp;secondary_console_sem);
		return;
	}

	console_may_schedule = 0;

	for ( ; ; ) {
		spin_lock_irqsave(&amp;logbuf_lock, flags);
		wake_klogd |= log_start - log_end;
		if (con_start == log_end)
			break;			/* Nothing to print */
		_con_start = con_start;
		_log_end = log_end;
		con_start = log_end;		/* Flush */
		spin_unlock(&amp;logbuf_lock);
		stop_critical_timings();	/* don't trace print latency */
		call_console_drivers(_con_start, _log_end);
		start_critical_timings();
		local_irq_restore(flags);
	}
	console_locked = 0;
	up(&amp;console_sem);
	spin_unlock_irqrestore(&amp;logbuf_lock, flags);
	if (wake_klogd)
		wake_up_klogd();
}
</pre><p>
call_console_drivers&#20989;&#25968;&#22312;&#26368;&#32456;&#26159;&#36890;&#36807;__call_console_drivers&#20989;&#25968;&#26469;&#23454;&#29616;&#30340;&#12290;&#25152;&#26377;&#30340;&#20018;&#21475;&#39537;&#21160;&#37117;&#36890;&#36807;register_console&#27880;&#20876;&#21040;console_drivers&#38142;&#34920;&#20013;&#65292;&#24403;printk&#20390;&#27979;&#21040;&#26377;&#21487;&#20197;&#20351;&#29992;&#30340;&#32456;&#31471;&#65292;&#37027;&#20040;&#23601;&#23558;&#20449;&#24687;&#36890;&#36807;&#39537;&#21160;&#30340;write&#20989;&#25968;&#20889;&#20986;&#12290;
</p><pre class="programlisting">
static void __call_console_drivers(unsigned start, unsigned end)
{
	struct console *con;

	for (con = console_drivers; con; con = con-&gt;next) {
		if ((con-&gt;flags &amp; CON_ENABLED) &amp;&amp; con-&gt;write &amp;&amp;
				(cpu_online(smp_processor_id()) ||
				(con-&gt;flags &amp; CON_ANYTIME)))
			con-&gt;write(con, &amp;LOG_BUF(start), end - start);
	}
}
</pre><p>
log_buf&#30340;&#22823;&#23567;&#30001;__LOG_BUF_LEN&#23450;&#20041;&#65292;&#23427;&#21448;&#30001;.config&#20013;&#30340;CONFIG_LOG_BUF_SHIFT&#20915;&#23450;&#65292;&#36890;&#24120;&#20540;&#20026;17&#65292;&#20063;&#21363;128K&#30340;&#22823;&#23567;&#12290;log_buf&#25968;&#32452;&#34987;&#27169;&#25311;&#25104;&#29615;&#29366;&#38431;&#21015;&#65292;&#24403;&#20449;&#24687;&#24635;&#38271;&#24230;&#36229;&#36807;&#23427;&#30340;&#26368;&#22823;&#22823;&#23567;&#26102;&#65292;&#26032;&#30340;&#20449;&#24687;&#23558;&#35206;&#30422;&#26087;&#30340;&#20449;&#24687;&#12290;dmesg&#36755;&#20986;&#30340;&#20449;&#24687;&#23601;&#26159;&#20174;&#35813;&#32531;&#20914;&#21306;&#35835;&#20986;&#30340;&#12290;
</p><pre class="programlisting">
#define __LOG_BUF_LEN	(1 &lt;&lt; CONFIG_LOG_BUF_SHIFT)
......
static char __log_buf[__LOG_BUF_LEN];
static char *log_buf = __log_buf;
static int log_buf_len = __LOG_BUF_LEN;
</pre><p>
	</p>	
</div>

<div class="sect2" title="9.6. setup_arch"><div class="titlepage"><div><div><h3 class="title"><a name="idp80638060"></a>9.6. setup_arch</h3></div></div></div>
<p>
setup_arch&#26159;&#19968;&#20010;&#37325;&#37327;&#32423;&#20989;&#25968;&#65292;&#23427;&#20351;&#29992;Bootloader&#20256;&#36882;&#26469;&#30340;&#20869;&#26680;&#21442;&#25968;&#23545;&#29305;&#23450;&#26426;&#22120;&#26550;&#26500;&#39537;&#21160;&#31561;&#36827;&#34892;&#21021;&#22987;&#21270;&#12290;
</p><pre class="programlisting">
char *command_line;
......
setup_arch(&amp;command_line);
</pre><p>	
setup_arch&#29305;&#23450;&#20110;&#31995;&#32479;&#26550;&#26500;&#65292;init_tags&#30340;&#23450;&#20041;&#19982;bootloader&#20013;&#30340;struct tag&#38656;&#35201;&#20445;&#25345;&#19968;&#33268;&#65292;&#20351;&#29992;&#23427;&#26469;&#35299;&#26512;bootloader&#20256;&#36882;&#26469;&#30340;&#20869;&#26680;&#21442;&#25968;&#20197;&#21450;&#36890;&#36807;CONFIG_CMDLINE&#23450;&#20041;&#30340;&#21442;&#25968;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/setup.h
#define COMMAND_LINE_SIZE 1024

arch/arm/kernel/setup.c
static char default_command_line[COMMAND_LINE_SIZE] __initdata = CONFIG_CMDLINE;

void __init setup_arch(char **cmdline_p)
{
	struct tag *tags = (struct tag *)&amp;init_tags;
	struct machine_desc *mdesc;
	char *from = default_command_line;
</pre><p>
default_command_line&#36890;&#36807;CONFIG_CMDLINE&#20256;&#36882;&#36827;&#26469;&#65306;
</p><pre class="programlisting">
CONFIG_CMDLINE="root=/dev/mtdblock2 rootfstype=cramfs init=/linuxrc console=ttySAC0,115200 mem=256M"
</pre><p>

</p><pre class="programlisting">
	setup_processor();
</pre><p>
lookup_processor_type&#34987;&#23450;&#20041;&#22312;arch/arm/mm/proc-v6.S&#20013;&#12290;read_cpuid_id&#20174;CP15&#30340;&#23492;&#23384;&#22120;&#20013;&#35835;&#21462;CPU ID&#65292;&#28982;&#21518;&#26597;&#25214;&#21040;CPU&#23545;&#24212;&#30340;proc_info_list&#32467;&#26500;&#20307;&#12290;&#28982;&#21518;&#36890;&#36807;printk&#25171;&#21360;&#20986;CPU&#30340;&#30456;&#20851;&#20449;&#24687;&#12290;
</p><pre class="programlisting">
static void __init setup_processor(void)
{
	struct proc_info_list *list;

	......
	list = lookup_processor_type(read_cpuid_id());
	if (!list) {
		printk("CPU configuration botched (ID %08x), unable "
		       "to continue.\n", read_cpuid_id());
		while (1);
	}

	cpu_name = list-&gt;cpu_name;

	......
#ifdef MULTI_USER
	cpu_user = *list-&gt;user;
#endif
#ifdef MULTI_CACHE
	cpu_cache = *list-&gt;cache;
#endif

	printk("CPU: %s [%08x] revision %d (ARMv%s), cr=%08lx\n",
	       cpu_name, read_cpuid_id(), read_cpuid_id() &amp; 15,
	       proc_arch[cpu_architecture()], cr_alignment);

	sprintf(init_utsname()-&gt;machine, "%s%c", list-&gt;arch_name, ENDIANNESS);
	sprintf(elf_platform, "%s%c", list-&gt;elf_name, ENDIANNESS);
	elf_hwcap = list-&gt;elf_hwcap;
#ifndef CONFIG_ARM_THUMB
	elf_hwcap &amp;= ~HWCAP_THUMB;
#endif

	cacheid_init();
	cpu_proc_init();
}
</pre><p>
printk&#30340;&#36755;&#20986;&#22914;&#19979;&#25152;&#31034;&#65292;cpu_name&#20026;ARMv6-compatible processor&#65292;CPUID&#20026;410fb766&#65292;revision&#20026;6&#65292;processor arch&#20026;ARMv7&#12290;cr_alignment&#21017;&#20445;&#23384;&#20102;CP15&#20013;&#25511;&#21046;&#23492;&#23384;&#22120;C1&#30340;&#20540;&#12290;
</p><pre class="programlisting">
CPU: ARMv6-compatible processor [410fb766] revision 6 (ARMv7), cr=00c5387f
</pre><p>
read_cpuid_cachetype&#21644;cpu_architecture&#20998;&#21035;&#33719;&#21462;cachetype&#21644;arch&#65292;&#26681;&#25454;&#23427;&#20204;&#30830;&#23450;cacheid&#24182;&#25171;&#21360;&#36755;&#20986;&#12290;cpu_proc_init&#36890;&#36807;&#19968;&#20123;&#21015;&#30340;&#23439;&#23450;&#20041;&#26368;&#32456;&#35843;&#29992;&#21040;cpu_xxx_proc_init&#65292;&#36825;&#37324;&#20026;cpu_v6_proc_init&#65292;&#23427;&#36890;&#36807;&#27719;&#32534;&#35821;&#35328;&#23450;&#20041;&#22312;arch/arm/mm/proc_v6.S&#20013;&#65292;&#23436;&#25104;CPU&#30340;&#21021;&#22987;&#21270;&#12290;
</p><pre class="programlisting">
static void __init cacheid_init(void)
{
	unsigned int cachetype = read_cpuid_cachetype();
	unsigned int arch = cpu_architecture();

	if (arch &gt;= CPU_ARCH_ARMv7) {
		cacheid = CACHEID_VIPT_NONALIASING;
		if ((cachetype &amp; (3 &lt;&lt; 14)) == 1 &lt;&lt; 14)
			cacheid |= CACHEID_ASID_TAGGED;
	} else if (arch &gt;= CPU_ARCH_ARMv6) {
		if (cachetype &amp; (1 &lt;&lt; 23))
			cacheid = CACHEID_VIPT_ALIASING;
		else
			cacheid = CACHEID_VIPT_NONALIASING;
	} else {
		cacheid = CACHEID_VIVT;
	}

	printk("CPU: %s data cache, %s instruction cache\n",
		cache_is_vivt() ? "VIVT" :
		cache_is_vipt_aliasing() ? "VIPT aliasing" :
		cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown",
		cache_is_vivt() ? "VIVT" :
		icache_is_vivt_asid_tagged() ? "VIVT ASID tagged" :
		cache_is_vipt_aliasing() ? "VIPT aliasing" :
		cache_is_vipt_nonaliasing() ? "VIPT nonaliasing" : "unknown");
}
</pre><p>
</p><pre class="programlisting">
CPU: VIPT nonaliasing data cache, VIPT nonaliasing instruction cache
</pre><p>
&#25509;&#19979;&#26469;&#36890;&#36807;setup_machine&#29992;&#26426;&#22120;&#32534;&#21495;&#20316;&#20026;&#21442;&#25968;&#36820;&#22238;&#26426;&#22120;&#25551;&#36848;&#31526;&#12290;&#20174;&#26426;&#22120;&#25551;&#36848;&#31526;&#20013;&#33719;&#24471;&#20869;&#26680;&#21442;&#25968;&#30340;&#29289;&#29702;&#22320;&#22336;&#65292;&#36171;&#20540;&#32473;tags &#21464;&#37327;&#12290;&#28982;&#21518;&#35843;&#29992;parse_tags&#65288;&#65289;&#20989;&#25968;&#20998;&#26512;&#20869;&#26680;&#21442;&#25968;&#38142;&#34920;&#65292;&#25226;&#21508;&#20010;&#21442;&#25968;&#20540;&#20256;&#36882;&#32473;&#20840;&#23616;&#21464;&#37327;&#12290;&#36825;&#26679;&#20869;&#26680;&#23601;&#25910;&#21040;&#20102;BootLoader &#20256;&#36882;&#30340;&#21442;&#25968;&#12290;
</p><pre class="programlisting">
	mdesc = setup_machine(machine_arch_type);
	machine_name = mdesc-&gt;name;
</pre><p>
.config&#20013;&#23450;&#20041;&#20102;CONFIG_MACH_SMDK6410&#65292;&#22914;&#26524;&#23450;&#20041;&#20102;machine_arch_type&#65292;&#37027;&#20040;&#20256;&#36882;&#30340;&#20540;&#20174;bootloader&#20256;&#36882;&#26469;&#30340;__machine_arch_type&#24471;&#21040;&#65292;&#21542;&#21017;&#20026;MACH_TYPE_SMDK6410&#12290;
</p><pre class="programlisting">
include/asm/mach-types.h
#define MACH_TYPE_SMDK6410             1626
......
#ifdef CONFIG_MACH_SMDK6410
# ifdef machine_arch_type
#  undef machine_arch_type
#  define machine_arch_type     __machine_arch_type
# else
#  define machine_arch_type     MACH_TYPE_SMDK6410
# endif
# define machine_is_smdk6410()  (machine_arch_type == MACH_TYPE_SMDK6410)
#else
# define machine_is_smdk6410()  (0)
#endif
</pre><p>
setup_machine&#36890;&#36807;lookup_machine_type&#26597;&#25214;machine_desc&#32467;&#26500;&#20307;&#12290;lookup_machine_type&#36890;&#36807;&#27719;&#32534;&#23450;&#20041;&#12290;
</p><pre class="programlisting">
arch/arm/kernel/head-common.S
ENTRY(lookup_machine_type)
        stmfd   sp!, {r4 - r6, lr}
        mov     r1, r0
        bl      __lookup_machine_type
        mov     r0, r5
        ldmfd   sp!, {r4 - r6, pc}
ENDPROC(lookup_machine_type)

static struct machine_desc * __init setup_machine(unsigned int nr)
{
	struct machine_desc *list;

	list = lookup_machine_type(nr);
	if (!list) {
		printk("Machine configuration botched (nr %d), unable "
		       "to continue.\n", nr);
		while (1);
	}

	printk("Machine: %s\n", list-&gt;name);
	return list;
}
</pre><p>	
&#23454;&#38469;&#30340;&#26426;&#22120;&#26550;&#26500;&#21017;&#20301;&#20110;arch/arm/mach-xxx/mach-smdkxxx.c&#20013;&#65292;&#23545;&#20110;s3c6410&#20301;&#20110;arch/arm/mach-s3c6410/mach-smdk6410.c&#20013;&#65292;&#35831;&#21442;&#32771;<a class="xref" href="ar01s08.html#mach_type" title="8.3. &#26816;&#26597;&#26426;&#22120;&#31867;&#22411;">&#31532; 8.3 &#33410; &#8220;&#26816;&#26597;&#26426;&#22120;&#31867;&#22411;&#8221;</a>&#12290;Machine&#30340;&#21517;&#31216;&#36755;&#20986;&#22914;&#19979;&#65306;
</p><pre class="programlisting">
Machine: SMDK6410
</pre><p>
&#22914;&#26524;&#26426;&#22120;&#26550;&#26500;&#25552;&#20379;&#20102;soft_reboot&#65292;&#37027;&#20040;&#35828;&#26126;&#23427;&#25903;&#25345;&#36719;&#21551;&#21160;&#65292;&#35774;&#32622;&#21551;&#21160;&#27169;&#24335;&#20026;&#36719;&#21551;&#21160;"s"&#12290;
</p><pre class="programlisting">
if (mdesc-&gt;soft_reboot)
		reboot_setup("s");
</pre><p>
&#25509;&#30528;&#21028;&#26029;&#20174;bootloader&#26159;&#21542;&#32473;&#20869;&#26680;&#20256;&#36882;&#20102;&#21442;&#25968;&#65292;&#23427;&#36890;&#36807;__atags_pointer&#26469;&#20256;&#36882;&#65292;&#35831;&#21442;&#32771;<a class="xref" href="ar01s08.html#mach_type" title="8.3. &#26816;&#26597;&#26426;&#22120;&#31867;&#22411;">&#31532; 8.3 &#33410; &#8220;&#26816;&#26597;&#26426;&#22120;&#31867;&#22411;&#8221;</a>&#12290;&#30001;&#20110;__atags_pointer&#25351;&#23450;&#30340;&#26159;&#29289;&#29702;&#22320;&#22336;&#65292;&#36890;&#24120;&#20026;&#29289;&#29702;&#22320;&#22336;&#24320;&#22987;&#22788;&#30340;0x100&#22788;&#65292;&#36825;&#37324;&#20026;0x50000100&#65292;&#36716;&#25442;&#21518;&#30340;tags&#30340;&#22320;&#22336;&#25351;&#21521;0xc0000100&#12290;boot_params&#20013;&#30340;&#23450;&#20041;.boot_params  = S3C64XX_PA_SDRAM + 0x100&#19982;&#27492;&#30456;&#21516;&#12290;
</p><pre class="programlisting">
	if (__atags_pointer)
		tags = phys_to_virt(__atags_pointer);
	else if (mdesc-&gt;boot_params)
		tags = phys_to_virt(mdesc-&gt;boot_params);
</pre><p>
tags&#30340;&#31532;&#19968;&#20010;&#21442;&#25968;&#33410;&#28857;&#30340;&#31867;&#22411;&#24212;&#35813;&#26159;ATAG_CORE&#65292;&#22914;&#26524;&#19981;&#26159;&#21017;&#35748;&#20026;&#26159;&#36890;&#36807;&#26087;&#26041;&#24335;struct param_struct&#26469;&#36827;&#34892;&#20256;&#36882;&#21442;&#25968;&#65292;&#38656;&#36890;&#36807;convert_to_tag_list&#36827;&#34892;&#36716;&#25442;&#65292;&#36716;&#25442;&#21518;&#22914;&#26524;&#31532;&#19968;&#20010;&#21442;&#25968;&#33410;&#28857;&#30340;&#31867;&#22411;&#36824;&#19981;&#26159;ATAG_CORE&#65292;&#37027;&#20040;&#20351;&#29992;&#31995;&#32479;&#40664;&#35748;&#30340;init_tags&#21442;&#25968;&#21015;&#34920;&#12290;
</p><pre class="programlisting">
	if (tags-&gt;hdr.tag != ATAG_CORE)
		convert_to_tag_list(tags);
	if (tags-&gt;hdr.tag != ATAG_CORE)
		tags = (struct tag *)&amp;init_tags;
</pre><p>		
struct machine_desc&#25552;&#20379;&#20102;&#29992;&#26469;&#26144;&#23556;IO&#22320;&#22336;&#31354;&#38388;&#30340;&#20989;&#25968;&#65292;&#29992;&#26469;&#21021;&#22987;&#21270;&#20013;&#26029;&#25511;&#21046;&#22120;&#30340;&#20989;&#25968;&#65292;&#29992;&#26469;&#27880;&#20876;&#22806;&#22260;&#35774;&#22791;&#20989;&#25968;&#12290;&#32780;&#23545;&#20110;struct machine_desc &#27809;&#26377;&#33021;&#22815;&#35206;&#30422;&#21040;&#30340;&#22788;&#29702;&#20989;&#25968;&#65292;&#21487;&#20197;&#22312;fixup&#20989;&#25968;&#37324;&#22788;&#29702;&#12290;
</p><pre class="programlisting">
	if (mdesc-&gt;fixup)
		mdesc-&gt;fixup(mdesc, tags, &amp;from, &amp;meminfo);
</pre><p>
&#25509;&#19979;&#26469;&#23545;tags&#21442;&#25968;&#36827;&#34892;&#35299;&#26512;&#65292;meminfo.nr_banks&#27492;&#26102;&#24212;&#35813;&#26159;0&#65292;squash_mem_tags&#26159;&#23558;&#25152;&#26377;ATAG_MEM&#31867;&#22411;&#30340;&#33410;&#28857;&#25913;&#20026;ATAG_NONE&#20063;&#21363;&#22914;&#26524;meminfo.nr_banks&#19981;&#20026;0&#65292;&#21017;&#35748;&#20026;&#24050;&#32463;&#22788;&#29702;&#36807;&#20869;&#23384;&#21442;&#25968;&#65292;&#30452;&#25509;&#36339;&#36807;&#36825;&#20123;&#33410;&#28857;&#12290;&#21482;&#26377;&#23450;&#20041;&#20102;CONFIG_ATAGS_PROC&#65292;save_atags&#25165;&#26377;&#24847;&#20041;&#65292;&#27492;&#26102;tags&#34987;&#34987;&#22791;&#20221;&#21040;atags_copy[BOOT_PARAMS_SIZE]&#20013;&#12290;
</p><pre class="programlisting">
static struct meminfo meminfo __initdata = { 0, };
......
	if (tags-&gt;hdr.tag == ATAG_CORE) {
		if (meminfo.nr_banks != 0)
			squash_mem_tags(tags);
		save_atags(tags);
		parse_tags(tags);
	}
</pre><p>
parse_tags&#23545;&#21442;&#25968;&#36827;&#34892;&#35299;&#26512;&#65292;parse_tag&#26159;&#30495;&#27491;&#35299;&#26512;&#30340;&#20989;&#25968;&#12290;&#35299;&#26512;&#36807;&#31243;&#35814;&#35265;&#20869;&#26680;&#21442;&#25968;&#35299;&#26512;<sup>[<a name="idp80665532" href="#ftn.idp80665532" class="footnote">6</a>]</sup>
&#22312;&#35299;&#26512;&#23436;&#25152;&#26377;&#30340;&#21442;&#25968;&#20197;&#21518;&#65292;&#19979;&#38754;&#26159;init_mm&#30340;&#21021;&#22987;&#21270;&#65292;init_mm&#23450;&#20041;&#22312;arch/arm/kernel/init_task.c&#65306; 
include/linux/init_task.h
</p><pre class="programlisting">
#define INIT_MM(name) \
{                                                               \
        .mm_rb          = RB_ROOT,                              \
        .pgd            = swapper_pg_dir,                       \
        .mm_users       = ATOMIC_INIT(2),                       \
        .mm_count       = ATOMIC_INIT(1),                       \
        .mmap_sem       = __RWSEM_INITIALIZER(name.mmap_sem),   \
        .page_table_lock =  __SPIN_LOCK_UNLOCKED(name.page_table_lock), \
        .mmlist         = LIST_HEAD_INIT(name.mmlist),          \
        .cpu_vm_mask    = CPU_MASK_ALL,                         \
}

struct mm_struct init_mm = INIT_MM(init_mm); 
</pre><p>
&#20174;&#29616;&#22312;&#24320;&#22987;&#30340;&#30456;&#24403;&#19968;&#37096;&#20998;&#20869;&#23481;&#26159;&#21644;&#20869;&#23384;&#31649;&#29702;&#30456;&#20851;&#30340;&#65292;&#25805;&#20316;&#31995;&#32479;&#30340;&#20869;&#23384;&#31649;&#29702;&#26159;&#24456;&#22797;&#26434;&#30340;&#65292;&#29301;&#25199;&#21040;&#22788;&#29702;&#22120;&#30340;&#30828;&#20214;&#32454;&#33410;&#21644;&#36719;&#20214;&#31639;&#27861;&#65292;&#38656;&#35201;&#28145;&#20837;&#20102;&#35299;ARM MMU&#26426;&#21046;&#12290;&#36825;&#37324;&#35774;&#32622;init_mm&#30340;&#20195;&#30721;&#27573;&#21644;&#25968;&#25454;&#27573;&#12290;
</p><pre class="programlisting">
	init_mm.start_code = (unsigned long) &amp;_text;
	init_mm.end_code   = (unsigned long) &amp;_etext;
	init_mm.end_data   = (unsigned long) &amp;_edata;
	init_mm.brk	   = (unsigned long) &amp;_end;
</pre><p>
&#27492;&#26102;&#30340;&#20869;&#26680;&#22312;RAM&#20013;&#30340;&#24067;&#23616;&#22914;&#19979;&#25152;&#31034;&#65306;
</p><div class="figure"><a name="idp80674124"></a><p class="title"><b>&#22270; 47. &#20869;&#26680;RAM&#24067;&#23616;</b></p><div class="figure-contents"><div><img src="images/kernelmap.gif" alt="&#20869;&#26680;RAM&#24067;&#23616;"></div></div></div><p><br class="figure-break">
&#25509;&#30528;&#22312;.config&#20013;&#37197;&#32622;&#30340;CONFIG_CMDLINE&#34987;&#22791;&#20221;&#21040;boot_command_line&#65292;&#23427;&#23558;&#34987;&#22312;setup_kernel&#20013;&#20351;&#29992;&#12290;
</p><pre class="programlisting">
	memcpy(boot_command_line, from, COMMAND_LINE_SIZE);
	boot_command_line[COMMAND_LINE_SIZE-1] = '\0';
	parse_cmdline(cmdline_p, from);
</pre><p>
parse_cmdline&#29992;&#26469;&#35299;&#26512;CONFIG_CMDLINE&#25110;Bootloader&#20256;&#36882;&#26469;&#30340;&#21442;&#25968;&#65292;cmdline_p&#20174;start_arch&#20256;&#36882;&#32780;&#26469;&#65292;&#23427;&#23558;&#36820;&#22238;&#27809;&#26377;&#35299;&#26512;&#30340;&#20854;&#20313;&#21442;&#25968;&#12290;
</p><pre class="programlisting">
static void __init parse_cmdline(char **cmdline_p, char *from)
{
	char c = ' ', *to = command_line;
	int len = 0;

	for (;;) {
		if (c == ' ') {
			extern struct early_params __early_begin, __early_end;
			struct early_params *p;

			for (p = &amp;__early_begin; p &lt; &amp;__early_end; p++) {
				int arglen = strlen(p-&gt;arg);
			......
			}
		}
		......
	}
	*to = '\0';
	*cmdline_p = command_line;
}
</pre><p>
__early_begin&#21644;__early_en&#22312;vmlinux.lds.S&#20013;&#23450;&#20041;&#65292;&#26174;&#28982;&#25152;&#26377;&#21517;&#20026;.early_param.init&#30340;&#27573;&#37117;&#21253;&#21547;&#22312;&#20854;&#20013;&#12290;
</p><pre class="programlisting">
__early_begin = .;
    *(.early_param.init)
__early_end = .;
</pre><p>
__early_param&#23450;&#20041;&#20102;&#36825;&#20123;&#20301;&#20110;.early_param.init&#27573;&#20013;&#30340;&#20195;&#30721;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/setup.h
struct early_params {
        const char *arg;
        void (*fn)(char **p);
};

#define __early_param(name,fn)                                  \
static struct early_params __early_##fn __used                  \
__attribute__((__section__(".early_param.init"))) = { name, fn }
</pre><p>
&#22312;arch/arm&#20013;&#25628;&#32034;__early_param&#30340;&#32467;&#26524;&#22914;&#19979;&#65306;
</p><pre class="programlisting">
./mm/mmu.c:123:__early_param("cachepolicy=", early_cachepolicy);
./mm/mmu.c:131:__early_param("nocache", early_nocache);
./mm/mmu.c:139:__early_param("nowb", early_nowrite);
./mm/mmu.c:151:__early_param("ecc=", early_ecc);
./mm/mmu.c:650:__early_param("vmalloc=", early_vmalloc);
./mm/init.c:44:__early_param("initrd=", early_initrd);
./kernel/setup.c:413:__early_param("mem=", early_mem);
</pre><p>
&#23545;&#29031;bootargs&#30340;&#20869;&#23481;"root=/dev/mtdblock2 rootfstype=cramfs init=/linuxrc console=ttySAC0,115200 mem=256M"&#65292;&#20854;&#20013;&#30340;mem&#21442;&#25968;&#23558;&#24471;&#21040;&#22788;&#29702;&#12290;early_mem&#31867;&#20284;&#20110;parse_tag_mem32&#65292;&#20294;&#26159;&#23427;&#23558;&#24320;&#22987;&#22320;&#22336;&#35774;&#32622;&#20026;&#40664;&#35748;&#30340;&#29289;&#29702;&#20559;&#31227;&#22320;&#22336;PHYS_OFFSET&#65292;&#22823;&#23567;&#30001;&#21442;&#25968;mem&#30340;&#20540;&#25351;&#23450;&#65292;&#24182;&#19988;&#22914;&#26524;&#20351;&#29992;early_mem&#26469;&#28155;&#21152;bank&#37027;&#20040;&#20808;&#21069;&#36890;&#36807;parse_tag_mem32&#28155;&#21152;&#30340;bank&#23558;&#34987;&#28165;&#38500;&#65292;&#20063;&#21363;&#29992;&#25143;&#25351;&#23450;&#30340;mem&#30340;&#20248;&#20808;&#32423;&#39640;&#20110;Bootload&#22312;&#21551;&#21160;&#20013;&#20256;&#36882;&#30340;&#21442;&#25968;&#12290;
</p><pre class="programlisting">
static void __init early_mem(char **p)
{
	static int usermem __initdata = 0;
	unsigned long size, start;

	/*
	 * If the user specifies memory size, we
	 * blow away any automatically generated
	 * size.
	 */
	if (usermem == 0) {
		usermem = 1;
		meminfo.nr_banks = 0;
	}

	start = PHYS_OFFSET;
	size  = memparse(*p, p);
	if (**p == '@')
		start = memparse(*p + 1, p);

	arm_add_memory(start, size);
}
</pre><p>
</p>
<p>
</p>	
</div>
<div class="sect2" title="9.7. &#30452;&#25509;&#22320;&#22336;&#36716;&#25442;"><div class="titlepage"><div><div><h3 class="title"><a name="idp80679828"></a>9.7. &#30452;&#25509;&#22320;&#22336;&#36716;&#25442;</h3></div></div></div>
&#20869;&#26680;&#23450;&#20041;&#20102;&#20004;&#20010;&#23439;&#26469;&#36827;&#34892;&#29289;&#29702;&#22320;&#22336;&#21644;&#34394;&#25311;&#22320;&#22336;&#20043;&#38388;&#30340;&#36716;&#25442;&#12290;&#27880;&#24847;&#36825;&#37324;&#30340;&#36716;&#25442;&#21482;&#26377;&#22312;&#30452;&#25509;&#26144;&#23556;&#30340;&#24773;&#20917;&#19979;&#25165;&#26377;&#25928;&#65292;&#20063;&#21363;&#22312;&#20351;&#29992;&#27573;&#39029;&#34920;&#30340;&#24773;&#20917;&#19979;&#25165;&#26377;&#25928;&#65292;&#23427;&#20204;&#34987;&#32447;&#24615;&#26144;&#23556;&#65292;&#29289;&#29702;&#22320;&#22336;&#21644;&#34394;&#25311;&#22320;&#22336;&#38388;&#30340;&#20559;&#31227;&#20445;&#25345;&#19968;&#33268;&#65292;&#36890;&#36807;&#30452;&#25509;&#30340;&#21152;&#20943;&#36827;&#34892;&#36716;&#25442;&#12290;&#34394;&#25311;&#22320;&#22336;&#20943;&#21435;&#34394;&#25311;&#22320;&#22336;&#30340;&#20559;&#31227;&#22320;&#22336;PAGE_OFFSET(0xc0000000)&#28982;&#21518;&#21152;&#19978;&#29289;&#29702;&#22320;&#22336;&#30340;&#20559;&#31227;&#22320;&#22336;(0x50000000)&#21363;&#21487;&#24471;&#21040;&#23545;&#24212;&#30340;&#30340;&#29289;&#29702;&#22320;&#22336;&#65292;&#21453;&#21521;&#20134;&#28982;&#12290;
<pre class="programlisting">
arch/arm/include/asm/memory.h

#ifndef __virt_to_phys
#define __virt_to_phys(x)       ((x) - PAGE_OFFSET + PHYS_OFFSET)
#define __phys_to_virt(x)       ((x) - PHYS_OFFSET + PAGE_OFFSET)
#endif
......
static inline unsigned long virt_to_phys(void *x)
{
        return __virt_to_phys((unsigned long)(x));
}

static inline void *phys_to_virt(unsigned long x)
{
        return (void *)(__phys_to_virt((unsigned long)(x)));
}
</pre>
</div>
<div class="sect2" title="9.8. &#20869;&#26680;&#39029;&#34920;"><div class="titlepage"><div><div><h3 class="title"><a name="idp80681500"></a>9.8. &#20869;&#26680;&#39029;&#34920;</h3></div></div></div>
<p>
&#36825;&#37096;&#20998;&#30340;&#20027;&#35201;&#24037;&#20316;&#24314;&#31435;&#39029;&#34920;&#65292;&#21021;&#22987;&#21270;&#20869;&#23384;&#12290;
</p><pre class="programlisting">
paging_init(&amp;meminfo, mdesc);
	
arch/arm/mm/mmu.c	
void __init paging_init(struct meminfo *mi, struct machine_desc *mdesc)
{
	void *zero_page;

	build_mem_type_table();
	sanity_check_meminfo(mi);
	prepare_page_table(mi);
	bootmem_init(mi);
	devicemaps_init(mdesc);

	top_pmd = pmd_off_k(0xffff0000);

	/*
	 * allocate the zero page.  Note that we count on this going ok.
	 */
	zero_page = alloc_bootmem_low_pages(PAGE_SIZE);
	memzero(zero_page, PAGE_SIZE);
	empty_zero_page = virt_to_page(zero_page);
	flush_dcache_page(empty_zero_page);
}
</pre><p>
build_mem_type_table&#20027;&#35201;&#26159;&#29992;&#26469;&#24314;&#31435;&#21508;&#31181;&#31867;&#22411;&#30340;&#39029;&#34920;&#36873;&#39033;(&#27604;&#22914;&#20869;&#23384;&#26159;MEMORY&#31867;&#22411;&#65292;&#35774;&#22791;&#26159;DEVICE&#65292;&#20013;&#26029;&#21521;&#37327;&#34920;&#26159;HIGH_VECTORS)&#12290;
</p><pre class="programlisting">
static void __init build_mem_type_table(void)
{
	struct cachepolicy *cp;
	unsigned int cr = get_cr();
	unsigned int user_pgprot, kern_pgprot, vecs_pgprot;
	int cpu_arch = cpu_architecture();
	int i;
</pre><p>
get_cr&#33719;&#21462;cp15&#22788;&#29702;&#22120;&#30340;&#25511;&#21046;&#23492;&#23384;&#22120;c1&#30340;&#20540;&#12290;cpu_architecture&#33719;&#21462;CPU&#26550;&#26500;&#65292;S3C5410&#23545;&#24212;&#30340;&#20540;&#20026;9&#65292;&#20063;&#21363;ARMv7&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/system.h
#define CPU_ARCH_UNKNOWN        0
#define CPU_ARCH_ARMv3          1
#define CPU_ARCH_ARMv4          2
#define CPU_ARCH_ARMv4T         3
#define CPU_ARCH_ARMv5          4
#define CPU_ARCH_ARMv5T         5
#define CPU_ARCH_ARMv5TE        6
#define CPU_ARCH_ARMv5TEJ       7
#define CPU_ARCH_ARMv6          8
#define CPU_ARCH_ARMv7          9
</pre><p>
S3C5410&#19981;&#26159;Xscale 3&#65292;&#24182;&#19988;&#27880;&#24847;&#21040;&#21069;&#38754;&#36755;&#20986;&#30340;cr=00c5387f&#65292;CR_XP&#23545;&#24212;&#21040;&#31532;23&#20301;&#65292;&#25152;&#20197;cr&#19982;CR_XP&#20026;&#30495;&#65292;&#20250;&#36827;&#20837;&#22914;&#19979;&#20195;&#30721;&#20174;&#32780;&#25110;&#24471;&#20869;&#23384;&#31867;&#22411;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/system.h
#define CR_XP   (1 &lt;&lt; 23)       /* Extended page tables                 */

......
if (cpu_is_xsc3() || (cpu_arch &gt;= CPU_ARCH_ARMv6 &amp;&amp; (cr &amp; CR_XP))) {
		if (!cpu_is_xsc3()) {
			/*
			 * Mark device regions on ARMv6+ as execute-never
			 * to prevent speculative instruction fetches.
			 */
			mem_types[MT_DEVICE].prot_sect |= PMD_SECT_XN;
			mem_types[MT_DEVICE_NONSHARED].prot_sect |= PMD_SECT_XN;
			mem_types[MT_DEVICE_CACHED].prot_sect |= PMD_SECT_XN;
			mem_types[MT_DEVICE_WC].prot_sect |= PMD_SECT_XN;
		}
		......
</pre><p>

</p><pre class="programlisting">
arch/arm/mm/mm.h
struct mem_type {
        unsigned int prot_pte;
        unsigned int prot_l1;
        unsigned int prot_sect;
        unsigned int domain;
};
</pre><p>
struct cachepolicy *cp&#29992;&#26469;&#22788;&#29702;&#26144;&#23556;&#31574;&#30053;&#12290;&#23427;&#22312;&#21021;&#22987;&#21270;&#26102;&#34987;&#36171;&#20540;&#20026;CPOLICY_WRITEBACK&#12290;&#20026;&#20102;&#20445;&#35777;cache&#21644;memory&#30340;&#25968;&#25454;&#19968;&#33268;&#24615;&#65292;&#36890;&#24120;&#26377;&#19977;&#31181;&#26041;&#27861;&#65306;
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">write through&#65306;CPU&#21521;cache&#20889;&#20837;&#25968;&#25454;&#26102;&#65292;&#21516;&#26102;&#21521;memory&#20063;&#20889;&#19968;&#20221;&#65292;&#20351;cache&#21644;memory&#30340;&#25968;&#25454;&#20445;&#25345;&#19968;&#33268;&#12290;&#20248;&#28857;&#26159;&#31616;&#21333;&#65292;&#32570;&#28857;&#26159;&#27599;&#27425;&#37117;&#35201;&#35775;&#38382;memory&#65292;&#36895;&#24230;&#27604;&#36739;&#24930;&#12290;</li><li class="listitem">post write&#65306;CPU&#26356;&#26032;cache&#25968;&#25454;&#26102;&#65292;&#25226;&#26356;&#26032;&#30340;&#25968;&#25454;&#20889;&#20837;&#21040;&#19968;&#20010;&#26356;&#26032;&#32531;&#20914;&#22120;&#65292;&#22312;&#21512;&#36866;&#30340;&#26102;&#20505;&#25165;&#23545;memory&#36827;&#34892;&#26356;&#26032;&#12290;&#36825;&#26679;&#21487;&#20197;&#25552;&#39640;cache&#35775;&#38382;&#36895;&#24230;&#65292;&#20294;&#26159;&#65292;&#22312;&#25968;&#25454;&#36830;&#32493;&#34987;&#26356;&#26032;&#20004;&#27425;&#20197;&#19978;&#30340;&#26102;&#20505;&#65292;&#32531;&#20914;&#21306;&#23558;&#19981;&#22815;&#20351;&#29992;&#65292;&#34987;&#36843;&#21516;&#26102;&#26356;&#26032;memory&#12290;</li><li class="listitem">write back&#65306;CPU&#26356;&#26032;cache&#26102;&#65292;&#21482;&#26159;&#25226;&#26356;&#26032;&#30340;cache&#21306;&#26631;&#35760;&#19968;&#19979;&#65292;&#24182;&#19981;&#21516;&#27493;&#26356;&#26032;memory&#12290;&#21482;&#26159;&#22312;cache&#21306;&#35201;&#34987;&#26032;&#36827;&#20837;&#30340;&#25968;&#25454;&#21462;&#20195;&#26102;&#65292;&#25165;&#26356;&#26032;memory&#12290;&#36825;&#26679;&#20570;&#30340;&#21407;&#22240;&#26159;&#32771;&#34385;&#21040;&#24456;&#22810;&#26102;&#20505;cache&#23384;&#20837;&#30340;&#26159;&#20013;&#38388;&#32467;&#26524;&#65292;&#27809;&#26377;&#24517;&#35201;&#21516;&#27493;&#26356;&#26032;memory&#12290;&#20248;&#28857;&#26159;CPU&#25191;&#34892;&#30340;&#25928;&#29575;&#25552;&#39640;&#65292;&#32570;&#28857;&#26159;&#23454;&#29616;&#36215;&#26469;&#25216;&#26415;&#27604;&#36739;&#22797;&#26434;&#12290;</li></ul></div><p>
</p><pre class="programlisting">
static unsigned int cachepolicy __initdata = CPOLICY_WRITEBACK;
......
cp = &amp;cache_policies[cachepolicy];
vecs_pgprot = kern_pgprot = user_pgprot = cp-&gt;pte;
</pre><p>
cp&#23545;&#24212;&#30340;CPOLICY_WRITEBACK&#20869;&#23384;&#31574;&#30053;&#22914;&#19979;&#25152;&#31034;&#65292;vecs_pgprot&#65292;kern_pgprot&#21644;user_pgprot&#34987;&#36171;&#20540;&#20026;L_PTE_MT_WRITEBACK&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/pgtable.h
#define L_PTE_MT_WRITEBACK      (0x03 &lt;&lt; 2)     /* 0011 */

		.policy		= "writeback",
		.cr_mask	= 0,
		.pmd		= PMD_SECT_WB,
		.pte		= L_PTE_MT_WRITEBACK,
</pre><p>
</p><pre class="programlisting">
	if (cpu_arch &gt;= CPU_ARCH_ARMv6 &amp;&amp; (cr &amp; CR_XP)) {
		/*
		 * Mark cache clean areas and XIP ROM read only
		 * from SVC mode and no access from userspace.
		 */
		mem_types[MT_ROM].prot_sect |= PMD_SECT_APX|PMD_SECT_AP_WRITE;
		mem_types[MT_MINICLEAN].prot_sect |= PMD_SECT_APX|PMD_SECT_AP_WRITE;
		mem_types[MT_CACHECLEAN].prot_sect |= PMD_SECT_APX|PMD_SECT_AP_WRITE;
    ......
	}
</pre><p>
protection_map&#23450;&#20041;&#20102;16&#31181;&#20869;&#23384;&#35775;&#38382;&#26435;&#38480;&#65292;&#20854;&#20013;&#26144;&#23556;&#31867;&#22411;MAP_PRIVATE&#21644;MAP_SHARED&#21508;&#21344;8&#20010;&#12290;&#36825;&#37324;&#20026;&#20854;&#21152;&#19978;L_PTE_MT_WRITEBACK&#20301;&#12290;
</p><pre class="programlisting">
/mm/mmap.c 
pgprot_t protection_map[16] = {
        __P000, __P001, __P010, __P011, __P100, __P101, __P110, __P111,
        __S000, __S001, __S010, __S011, __S100, __S101, __S110, __S111
};

for (i = 0; i &lt; 16; i++) {
	unsigned long v = pgprot_val(protection_map[i]);
	protection_map[i] = __pgprot(v | user_pgprot);
}
</pre><p>

</p><pre class="programlisting">
	mem_types[MT_LOW_VECTORS].prot_pte |= vecs_pgprot;
	mem_types[MT_HIGH_VECTORS].prot_pte |= vecs_pgprot;

	pgprot_user   = __pgprot(L_PTE_PRESENT | L_PTE_YOUNG | user_pgprot);
	pgprot_kernel = __pgprot(L_PTE_PRESENT | L_PTE_YOUNG |
				 L_PTE_DIRTY | L_PTE_WRITE |
				 L_PTE_EXEC | kern_pgprot);

	mem_types[MT_LOW_VECTORS].prot_l1 |= ecc_mask;
	mem_types[MT_HIGH_VECTORS].prot_l1 |= ecc_mask;
	mem_types[MT_MEMORY].prot_sect |= ecc_mask | cp-&gt;pmd;
	mem_types[MT_ROM].prot_sect |= cp-&gt;pmd;

	switch (cp-&gt;pmd) {
	case PMD_SECT_WT:
		mem_types[MT_CACHECLEAN].prot_sect |= PMD_SECT_WT;
		break;
	case PMD_SECT_WB:
	case PMD_SECT_WBWA:
		mem_types[MT_CACHECLEAN].prot_sect |= PMD_SECT_WB;
		break;
	}
	printk("Memory policy: ECC %sabled, Data cache %s\n",
		ecc_mask ? "en" : "dis", cp-&gt;policy);
</pre><p>
</p><pre class="programlisting">
	for (i = 0; i &lt; ARRAY_SIZE(mem_types); i++) {
		struct mem_type *t = &amp;mem_types[i];
		if (t-&gt;prot_l1)
			t-&gt;prot_l1 |= PMD_DOMAIN(t-&gt;domain);
		if (t-&gt;prot_sect)
			t-&gt;prot_sect |= PMD_DOMAIN(t-&gt;domain);
	}
}
</pre><p>
&#36755;&#20986;&#32467;&#26524;&#22914;&#19979;&#65306;
</p><pre class="programlisting">
Memory policy: ECC disabled, Data cache writeback
</pre><p>
sanity_check_meminfo&#29992;&#20110;&#26816;&#26597;meminfo&#27880;&#20876;&#30340;&#20869;&#23384;bank&#30340;&#26377;&#25928;&#24615;&#65292;&#27604;&#22914;&#22823;&#23567;&#65292;&#26159;&#21542;&#37325;&#21472;&#31561;&#65292;&#26816;&#27979;&#38169;&#35823;&#30340;&#20869;&#23384;bank&#23558;&#34987;&#20174;meminfo&#20013;&#31227;&#38500;&#12290;prepare_page_table&#21017;&#29992;&#20110;&#21021;&#22987;&#21270;&#39029;&#34920;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/memory.h
#define MODULES_END             (PAGE_OFFSET)
#define MODULES_VADDR           (MODULES_END - 16*1048576)

static inline void prepare_page_table(struct meminfo *mi)
{
	unsigned long addr;

	/*
	 * Clear out all the mappings below the kernel image.
	 */
	for (addr = 0; addr &lt; MODULES_VADDR; addr += PGDIR_SIZE)
		pmd_clear(pmd_off_k(addr));

#ifdef CONFIG_XIP_KERNEL
	/* The XIP kernel is mapped in the module area -- skip over it */
	addr = ((unsigned long)&amp;_etext + PGDIR_SIZE - 1) &amp; PGDIR_MASK;
#endif
	for ( ; addr &lt; PAGE_OFFSET; addr += PGDIR_SIZE)
		pmd_clear(pmd_off_k(addr));

	/*
	 * Clear out all the kernel space mappings, except for the first
	 * memory bank, up to the end of the vmalloc region.
	 */
	for (addr = __phys_to_virt(mi-&gt;bank[0].start + mi-&gt;bank[0].size);
	     addr &lt; VMALLOC_END; addr += PGDIR_SIZE)
		pmd_clear(pmd_off_k(addr));
}
</pre><p>
1048576&#21363;&#20026;1M&#22823;&#23567;&#65292;MODULES_VADDR&#20026;PAGE_OFFSET&#20063;&#21363;0xc0000000&#21521;&#19979;&#20559;&#31227;&#30340;16M&#22320;&#22336;0xbf000000&#65292;&#23427;&#23450;&#20041;&#20102;&#20869;&#26680;&#27169;&#22359;&#21152;&#36733;&#30340;&#22320;&#22336;&#12290;&#36890;&#36807;lsmod&#25110;&#32773;proc&#31995;&#32479;&#21487;&#20197;&#20135;&#30475;&#24403;&#21069;&#31995;&#32479;&#20013;&#30340;&#27169;&#22359;&#22320;&#22336;&#20998;&#37197;&#24773;&#20917;,&#25152;&#26377;&#30340;&#27169;&#22359;&#22320;&#22336;&#24212;&#35813;&#20301;&#20110;MODULES_VADDR&#21644;MODULES_END&#20043;&#38388;&#12290;
</p><pre class="programlisting">
# cat /proc/modules 
hello 1216 0 - Live 0xbf000000
# lsmod 
hello 1216 0 - Live 0xbf000000
</pre><p>
VMALLOC_START&#21644;VMALLOC_END&#20998;&#21035;&#23450;&#20041;&#20102;&#20869;&#26680;&#22534;&#21306;&#30340;&#36215;&#22987;&#22320;&#22336;&#12290;VMALLOC_OFFSET&#23450;&#20041;&#20102;8M&#30340;&#31354;&#27934;&#65292;&#29992;&#20110;&#25429;&#25417;&#36234;&#30028;&#30340;&#20869;&#23384;&#35775;&#38382;&#12290;high_memory&#22312;asm-offsets.s&#20013;&#23450;&#20041;&#21644;&#21021;&#22987;&#21270;&#65292;&#24182;&#22312;&#21518;&#38754;&#30340;bootmem_init&#20989;&#25968;&#20013;&#36171;&#20540;&#65292;&#20294;&#26159;&#27492;&#26102;&#30340;&#20540;&#20381;&#28982;&#20026;0&#12290;&#25152;&#20197;VMALLOC_START&#30340;&#20540;&#20026;8M&#12290;bank[0].start &#21644;bank[0].size&#20998;&#21035;&#35760;&#24405;&#31532;&#19968;&#20010;&#20869;&#23384;bank&#30340;&#36215;&#22987;&#29289;&#29702;&#22320;&#22336;&#21644;&#22823;&#23567;&#65292;&#36825;&#37324;&#20026;0x50000000&#21644;0x10000000&#65292;&#23545;&#24212;&#30340;&#34394;&#25311;&#22320;&#22336;&#20026;0xc0000000 + 0x10000000&#20026;0xd0000000&#12290;&#25152;&#20197;&#25509;&#19979;&#37324;&#21021;&#22987;&#21270;0xd0000000&#21040;0xe0000000&#34394;&#25311;&#22320;&#22336;&#23545;&#24212;&#30340;&#27573;&#39029;&#34920;&#12290;
</p><pre class="programlisting">
arch/arm/plat-s3c/include/mach/vmalloc.h
#define VMALLOC_END       (0xE0000000)

arch/arm/include/asm/pgtable.h
#ifndef VMALLOC_START
#define VMALLOC_OFFSET          (8*1024*1024)
#define VMALLOC_START           (((unsigned long)high_memory + VMALLOC_OFFSET) &amp; ~(VMALLOC_OFFSET-1))
#endif

arch/arm/kernel/asm-offsets.s
.ascii  "high_memory\000"

arch/arm/mm/init.c
high_memory = __va(memend_pfn &lt;&lt; PAGE_SHIFT);
</pre><p>
Linux&#24635;&#26159;&#20551;&#23450;&#22788;&#29702;&#22120;&#26377;&#19977;&#32423;&#39029;&#34920;&#12290;
&#21253;&#25324;&#65306; 
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">&#39029;&#20840;&#23616;&#30446;&#24405; (Page Global Directory)&#65292;&#21363; pgd&#65292;&#26159;&#22810;&#32423;&#39029;&#34920;&#30340;&#25277;&#35937;&#26368;&#39640;&#23618;&#12290;&#27599;&#19968;&#32423;&#30340;&#39029;&#34920;&#37117;&#22788;&#29702;&#19981;&#21516;&#22823;&#23567;&#30340;&#20869;&#23384; &#8212;&#8212; &#36825;&#20010;&#20840;&#23616;&#30446;&#24405;&#21487;&#20197;&#22788;&#29702; 4 MB &#30340;&#21306;&#22495;&#12290;&#27599;&#39033;&#37117;&#25351;&#21521;&#19968;&#20010;&#26356;&#23567;&#30446;&#24405;&#30340;&#20302;&#32423;&#34920;&#65292;&#22240;&#27492; pgd &#23601;&#26159;&#19968;&#20010;&#39029;&#34920;&#30446;&#24405;&#12290;&#24403;&#20195;&#30721;&#36941;&#21382;&#36825;&#20010;&#32467;&#26500;&#26102;&#65288;&#26377;&#20123;&#39537;&#21160;&#31243;&#24207;&#23601;&#35201;&#36825;&#26679;&#20570;&#65289;&#65292;&#23601;&#31216;&#20026;&#26159;&#22312;&#8220;&#36941;&#21382;&#8221;&#39029;&#34920;&#12290; </li><li class="listitem">&#39029;&#20013;&#38388;&#30446;&#24405; (Page Middle Directory),&#21363; pmd&#65292;&#26159;&#39029;&#34920;&#30340;&#20013;&#38388;&#23618;&#12290;&#22312; x86 &#26550;&#26500;&#19978;&#65292;pmd &#22312;&#30828;&#20214;&#20013;&#24182;&#19981;&#23384;&#22312;&#65292;&#20294;&#26159;&#22312;&#20869;&#26680;&#20195;&#30721;&#20013;&#23427;&#26159;&#19982; pgd &#21512;&#24182;&#22312;&#19968;&#36215;&#30340;&#12290; </li><li class="listitem">&#39029;&#34920;&#26465;&#30446; (Page Table Entry)&#65292;&#21363; pte&#65292;&#26159;&#39029;&#34920;&#30340;&#26368;&#20302;&#23618;&#65292;&#23427;&#30452;&#25509;&#22788;&#29702;&#39029;&#65288;&#21442;&#30475;PAGE_SIZE&#65289;&#65292;&#35813;&#20540;&#21253;&#21547;&#26576;&#39029;&#30340;&#29289;&#29702;&#22320;&#22336;&#65292;&#36824;&#21253;&#21547;&#20102;&#35828;&#26126;&#35813;&#26465;&#30446;&#26159;&#21542;&#26377;&#25928;&#21450;&#30456;&#20851;&#39029;&#26159;&#21542;&#22312;&#29289;&#29702;&#20869;&#23384;&#20013;&#30340;&#20301;&#12290; </li></ul></div><p> 
clean_pmd_entry&#30340;&#20316;&#29992;&#26159;&#36890;&#36807;CP15&#28165;&#26970;MMU&#20013;&#30340;&#32531;&#20914;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/pgtable.h
#define pmd_clear(pmdp)                 \
        do {                            \
                pmdp[0] = __pmd(0);     \ 
                pmdp[1] = __pmd(0);     \
                clean_pmd_entry(pmdp);  \
        } while (0) 

arch/arm/include/asm/tlbflush.h
static inline void clean_pmd_entry(pmd_t *pmd)
{
        const unsigned int __tlb_flag = __cpu_tlb_flags;

        if (tlb_flag(TLB_DCLEAN))
                asm("mcr        p15, 0, %0, c7, c10, 1  @ flush_pmd"
                        : : "r" (pmd) : "cc");

        if (tlb_flag(TLB_L2CLEAN_FR))
                asm("mcr        p15, 1, %0, c15, c9, 1  @ L2 flush_pmd"
                        : : "r" (pmd) : "cc");
}
</pre><p>
</p><pre class="programlisting">
arch/arm/mm/mm.h
static inline pmd_t *pmd_off(pgd_t *pgd, unsigned long virt)
{
        return pmd_offset(pgd, virt);
}

static inline pmd_t *pmd_off_k(unsigned long virt)
{
        return pmd_off(pgd_offset_k(virt), virt);
}

arch/arm/include/asm/page.h
typedef struct { unsigned long pte; } pte_t;
typedef struct { unsigned long pmd; } pmd_t; 
typedef struct { unsigned long pgd[2]; } pgd_t;
typedef struct { unsigned long pgprot; } pgprot_t;

arch/arm/include/asm/pgtable.h
/* to find an entry in a page-table-directory */
#define PGDIR_SHIFT		21
#define PGDIR_SIZE		(1UL &lt;&lt; PGDIR_SHIFT)
#define pgd_index(addr)         ((addr) &gt;&gt; PGDIR_SHIFT)

#define pgd_offset(mm, addr)    ((mm)-&gt;pgd + pgd_index(addr))

/* to find an entry in a kernel page-table-directory */
#define pgd_offset_k(addr)      pgd_offset(&amp;init_mm, addr)

/* Find an entry in the second-level page table.. */
#define pmd_offset(dir, addr)   ((pmd_t *)(dir))
</pre><p>
pgd_index&#26681;&#25454;&#34394;&#25311;&#22320;&#22336;&#35745;&#31639;&#35813;&#22320;&#22336;&#23545;&#24212;&#30340;&#20840;&#23616;&#39029;&#30446;&#24405;&#32034;&#24341;&#65292;&#30452;&#25509;&#21462;&#39640;&#20301;11&#20301;&#65292;&#32780;&#20840;&#23616;&#39029;&#34920;&#23450;&#20041;&#20026;init_mm.pgd&#65292;&#26174;&#28982;&#20026;swapper_pg_dir&#12290;&#36825;&#37324;&#20026;0xc0004000&#12290;&#20869;&#26680;&#22312;kernel/head.S&#20013;&#36890;&#36807;__create_page_tables&#21019;&#24314;&#30340;&#27573;&#39029;&#34920;&#23601;&#20174;&#36825;&#37324;&#24320;&#22987;&#12290;&#39318;&#20808;&#23558;0-0xc0000000&#23545;&#24212;&#30340;&#27573;&#39029;&#34920;&#28165;&#38646;&#65292;&#36825;&#26159;&#20026;&#20102;&#24314;&#31435;&#20840;&#23616;&#39029;&#30446;&#24405;&#32034;&#24341;&#20570;&#20934;&#22791;&#12290;&#36825;&#37324;&#38656;&#35201;&#27880;&#24847;&#21040;pgd_offset&#30340;&#36816;&#31639;&#65292;&#30001;&#20110;pgd&#65292;&#20026;pgd_t*&#31867;&#22411;&#65292;&#25152;&#20197;&#20559;&#31227;&#20540;&#24635;&#26159;&#25353;&#29031;sizeof(pgd_t)&#30340;&#20540;8&#26469;&#20559;&#31227;&#65292;&#32780;&#38750;&#31616;&#21333;&#30340;&#30456;&#21152;&#12290;&#30001;&#20110;PGDIR_SIZE&#30340;&#20540;&#20026;2M&#65292;&#25152;&#20197;&#36825;&#37324;&#27599;&#27425;&#20559;&#31227;8&#65292;&#27491;&#22909;&#23545;&#24212;&#27573;&#39029;&#34920;&#30340;&#34920;&#39033;&#12290;
</p><pre class="programlisting">
arch/arm/kernel/head.S
#define KERNEL_RAM_VADDR	(PAGE_OFFSET + TEXT_OFFSET)
......
.globl  swapper_pg_dir
.equ    swapper_pg_dir, KERNEL_RAM_VADDR - 0x4000

.macro  pgtbl, rd
ldr     \rd, =(KERNEL_RAM_PADDR - 0x4000)
.endm
</pre><p>
</p><div class="figure"><a name="idp80702132"></a><p class="title"><b>&#22270; 48. &#20869;&#26680;PGD&#21021;&#22987;&#21270;</b></p><div class="figure-contents"><div><img src="images/kernelpgd.gif" alt="&#20869;&#26680;PGD&#21021;&#22987;&#21270;"></div></div></div><p><br class="figure-break">
</p>	
</div>
<div class="sect2" title="9.9. bootmem_init"><div class="titlepage"><div><div><h3 class="title"><a name="idp80681988"></a>9.9. bootmem_init</h3></div></div></div>
<p>
bootmem_init&#20026;&#20027;&#20869;&#23384;&#21019;&#24314;&#26144;&#23556;&#20851;&#31995;&#12290;&#36825;&#20010;&#20989;&#25968;&#36941;&#21382;&#25152;&#26377;&#33410;&#28857;&#65292;&#20026;&#27599;&#20010;&#33410;&#28857;&#35843;&#29992;bootmem_init_node()&#65292;&#23436;&#25104;&#25351;&#23450;&#33410;&#28857;&#20869;&#23384;&#30340;&#26144;&#23556;&#21019;&#24314;&#12290;
</p><pre class="programlisting">
/*
 * This is used to pass memory configuration data from paging_init
 * to mem_init, and by show_mem() to skip holes in the memory map.
 */

arch/arm/mm/init.c
static struct meminfo meminfo = { 0, };
......
void __init bootmem_init(struct meminfo *mi)
{
        unsigned long memend_pfn = 0;
        int node, initrd_node;

        memcpy(&amp;meminfo, mi, sizeof(meminfo));

        /*
         * Locate which node contains the ramdisk image, if any.
         */
        initrd_node = check_initrd(mi);
</pre><p>
&#39318;&#20808;&#23558;&#22791;&#20221;&#20256;&#20837;&#30340;&#21442;&#25968;mi&#21040;static&#31867;&#22411;&#30340;meminfo&#20013;&#65292;&#23427;&#34987;&#29992;&#26469;&#20174;paging_init&#20256;&#36882;&#20869;&#23384;&#37197;&#32622;&#20449;&#24687;&#32473;mem_init&#21644;show_mem&#20351;&#29992;&#12290;check_initrd&#22312;&#37197;&#32622;CONFIG_BLK_DEV_INITRD&#26102;&#29992;&#26469;&#26816;&#26597;ramdisk&#38236;&#20687;&#25152;&#22312;&#30340;&#20869;&#23384;bank&#65292;&#21542;&#21017;&#36820;&#22238;-2&#12290;
</p><pre class="programlisting">
        /*
         * Run through each node initialising the bootmem allocator.
         */
        for_each_node(node) {
                unsigned long end_pfn = bootmem_init_node(node, mi);

                /*
                 * Reserve any special node zero regions.
                 */
                if (node == 0)
                        reserve_node_zero(NODE_DATA(node));

                /*
                 * If the initrd is in this node, reserve its memory.
                 */
                if (node == initrd_node)
                        bootmem_reserve_initrd(node);

                /*
                 * Remember the highest memory PFN.
                 */
                if (end_pfn &gt; memend_pfn)
                        memend_pfn = end_pfn;
        }
</pre><p>
&#65292;bootmem_init_node()&#36941;&#21382;&#25972;&#20010;meminfo &#32467;&#26500;&#65292;&#20026;&#25351;&#23450;&#33410;&#28857;&#31867;&#22411;&#30340;Bank&#21019;&#24314;&#26144;&#23556;&#12290;&#20026;&#19968;&#20010;Bank &#21019;&#24314;&#26144;&#23556;&#26159;&#36890;&#36807;&#20989;&#25968;map_mamory_bank()&#23454;&#29616;&#30340;&#12290;
</p><pre class="programlisting">
static unsigned long __init bootmem_init_node(int node, struct meminfo *mi)
{
	unsigned long start_pfn, end_pfn, boot_pfn;
	unsigned int boot_pages;
	pg_data_t *pgdat;
	int i;

	start_pfn = -1UL;
	end_pfn = 0;

	/*
	 * Calculate the pfn range, and map the memory banks for this node.
	 */
	for_each_nodebank(i, mi, node) {
		struct membank *bank = &amp;mi-&gt;bank[i];
		unsigned long start, end;

		start = bank_pfn_start(bank);
		end = bank_pfn_end(bank);

		if (start_pfn &gt; start)
			start_pfn = start;
		if (end_pfn &lt; end)
			end_pfn = end;

		map_memory_bank(bank);
	}
</pre><p>
bank_pfn_start&#21644;bank_pfn_end&#22343;&#20026;&#23439;&#23450;&#20041;&#65292;&#23427;&#20204;&#23454;&#29616;&#23558;bank&#20013;&#30340;&#29289;&#29702;&#22320;&#22336;&#36716;&#25442;&#21040;&#39029;&#24103;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/memory.h
#define __phys_to_pfn(paddr)    ((paddr) &gt;&gt; PAGE_SHIFT)
#define __pfn_to_phys(pfn)      ((pfn) &lt;&lt; PAGE_SHIFT)

arch/arm/include/asm/setup.h
#define bank_pfn_start(bank)    __phys_to_pfn((bank)-&gt;start)
#define bank_pfn_end(bank)      __phys_to_pfn((bank)-&gt;start + (bank)-&gt;size)
#define bank_pfn_size(bank)     ((bank)-&gt;size &gt;&gt; PAGE_SHIFT)
#define bank_phys_start(bank)   (bank)-&gt;start
#define bank_phys_end(bank)     ((bank)-&gt;start + (bank)-&gt;size)
#define bank_phys_size(bank)    (bank)-&gt;size
</pre><p>
map_memory_bank()&#35843;&#29992;create_mapping()&#23436;&#25104;&#26144;&#23556;&#30340;&#21019;&#24314;&#24037;&#20316;&#12290;create_mapping()&#20989;&#25968;&#29992;&#20110;&#20026;&#19968;&#20010;&#29289;&#29702;&#23384;&#20648;&#31354;&#38388;&#21019;&#24314;&#26144;&#23556;&#65292;&#23454;&#38469;&#19978;&#23601;&#26159;&#22635;&#20805;&#39029;&#34920;&#12290;
</p><pre class="programlisting">
arch/arm/mm/init.c
static inline void map_memory_bank(struct membank *bank)
{
#ifdef CONFIG_MMU
        struct map_desc map;

        map.pfn = bank_pfn_start(bank);
        map.virtual = __phys_to_virt(bank_phys_start(bank));
        map.length = bank_phys_size(bank);
        map.type = MT_MEMORY;

        create_mapping(&amp;map);
#endif
}
</pre><p>
TASK_SIZE&#23450;&#20041;&#20102;&#19968;&#20010;&#36827;&#31243;&#30340;&#26368;&#22823;&#29992;&#25143;&#31354;&#38388;&#65292;&#26174;&#28982;&#23427;&#26368;&#22823;&#21482;&#33021;&#20026;MODULES_VADDR&#65292;&#20063;&#21363;0xbf000000&#12290;&#39318;&#20808;&#21028;&#26029;&#23427;&#19981;&#23646;&#20110;&#29992;&#25143;&#31354;&#38388;&#65292;&#22240;&#20026;&#29992;&#25143;&#31354;&#38388;&#30340;&#22320;&#22336;&#22312;&#33539;&#22260;0x0-0xbeffffff&#20043;&#38388;&#65292;&#20854;&#20313;&#22320;&#22336;&#35201;&#20040;&#20026;&#20869;&#26680;&#31354;&#38388;&#65292;&#35201;&#20040;&#20026;&#29305;&#23450;&#29992;&#36884;&#32780;&#21344;&#29992;&#12290;&#32039;&#25509;&#30528;&#26681;&#25454;&#20869;&#23384;&#31867;&#22411;&#20570;&#26816;&#26597;&#65292;&#22240;&#20026;&#36825;&#37324;&#23450;&#20041;&#30340;&#26159;MT_MEMORY&#65292;&#25152;&#20197;&#19981;&#20250;&#34987;&#21305;&#37197;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/memory.h
#define TASK_SIZE   (UL(CONFIG_PAGE_OFFSET) - UL(0x01000000))

arch/arm/mm/mmu.c
void __init create_mapping(struct map_desc *md)
{
	unsigned long phys, addr, length, end;
	const struct mem_type *type;
	pgd_t *pgd;

	if (md-&gt;virtual != vectors_base() &amp;&amp; md-&gt;virtual &lt; TASK_SIZE) {
		printk(KERN_WARNING "BUG: not creating mapping for "
		       "0x%08llx at 0x%08lx in user region\n",
		       __pfn_to_phys((u64)md-&gt;pfn), md-&gt;virtual);
		return;
	}

	if ((md-&gt;type == MT_DEVICE || md-&gt;type == MT_ROM) &amp;&amp;
	    md-&gt;virtual &gt;= PAGE_OFFSET &amp;&amp; md-&gt;virtual &lt; VMALLOC_END) {
		printk(KERN_WARNING "BUG: mapping for 0x%08llx at 0x%08lx "
		       "overlaps vmalloc space\n",
		       __pfn_to_phys((u64)md-&gt;pfn), md-&gt;virtual);
	}

	type = &amp;mem_types[md-&gt;type];

	/*
	 * Catch 36-bit addresses
	 */
	if (md-&gt;pfn &gt;= 0x100000) {
		create_36bit_mapping(md, type);
		return;
	}

	addr = md-&gt;virtual &amp; PAGE_MASK;
	phys = (unsigned long)__pfn_to_phys(md-&gt;pfn);
	length = PAGE_ALIGN(md-&gt;length + (md-&gt;virtual &amp; ~PAGE_MASK));

	if (type-&gt;prot_l1 == 0 &amp;&amp; ((addr | phys | length) &amp; ~SECTION_MASK)) {
		printk(KERN_WARNING "BUG: map for 0x%08lx at 0x%08lx can not "
		       "be mapped using pages, ignoring.\n",
		       __pfn_to_phys(md-&gt;pfn), addr);
		return;
	}

	pgd = pgd_offset_k(addr);
	end = addr + length;
	do {
		unsigned long next = pgd_addr_end(addr, end);

		alloc_init_section(pgd, addr, next, phys, type);

		phys += next - addr;
		addr = next;
	} while (pgd++, addr != end);
}
</pre><p>
alloc_init_section&#24403;&#22823;&#23567;&#21644;&#22320;&#22336;1MB&#23545;&#40784;&#26102;&#65292;&#20351;&#29992;&#27573;&#26144;&#23556;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/pgtable.h
#define SECTION_SHIFT           20
#define SECTION_SIZE            (1UL &lt;&lt; SECTION_SHIFT)
#define SECTION_MASK            (~(SECTION_SIZE-1))
</pre><p>
</p><pre class="programlisting">
include/asm-generic/pgtable.h
#define pgd_addr_end(addr, end)                                         \
({      unsigned long __boundary = ((addr) + PGDIR_SIZE) &amp; PGDIR_MASK;  \
        (__boundary - 1 &lt; (end) - 1)? __boundary: (end);                \
})

static void __init alloc_init_section(pgd_t *pgd, unsigned long addr,
                                      unsigned long end, unsigned long phys,
                                      const struct mem_type *type)
{
        pmd_t *pmd = pmd_offset(pgd, addr);

        /*
         * Try a section mapping - end, addr and phys must all be aligned
         * to a section boundary.  Note that PMDs refer to the individual
         * L1 entries, whereas PGDs refer to a group of L1 entries making
         * up one logical pointer to an L2 table.
         */
        if (((addr | end | phys) &amp; ~SECTION_MASK) == 0) {
                pmd_t *p = pmd;

                if (addr &amp; SECTION_SIZE)
                        pmd++;

                do {
                        *pmd = __pmd(phys | type-&gt;prot_sect);
                        phys += SECTION_SIZE;
                } while (pmd++, addr += SECTION_SIZE, addr != end);

                flush_pmd_entry(p);
        } else {
                /*
                 * No need to loop; pte's aren't interested in the
                 * individual L1 entries.
                 */
                alloc_init_pte(pmd, addr, end, __phys_to_pfn(phys), type);
        }
}
</pre><p>
&#30001;&#20110;&#24403;&#21069;&#20165;&#20165;&#23450;&#20041;&#20102;&#19968;&#20010;&#20869;&#23384;Bank&#65292;&#25152;&#20197;&#20197;&#19978;&#36807;&#31243;&#22788;&#29702;&#21518;&#65292;&#23558;&#23545;&#29289;&#29702;FLASH&#22320;&#22336;&#25152;&#21344;&#30340;&#22320;&#22336;&#36827;&#34892;&#39029;&#34920;&#26144;&#23556;&#65292;&#22914;&#19979;&#22270;&#25152;&#31034;&#65306;
</p><div class="figure"><a name="idp80713748"></a><p class="title"><b>&#22270; 49. &#20869;&#26680;FLASH&#22320;&#22336;&#23545;&#24212;&#30340;&#39029;&#34920;</b></p><div class="figure-contents"><div><img src="images/kernel_flash_map.gif" alt="&#20869;&#26680;FLASH&#22320;&#22336;&#23545;&#24212;&#30340;&#39029;&#34920;"></div></div></div><p><br class="figure-break">
reserve_node_zero&#20989;&#25968;&#30340;&#20316;&#29992;&#26159;&#20445;&#30041;&#19968;&#37096;&#20998;&#20869;&#23384;&#20351;&#20043;&#19981;&#33021;&#34987;&#21160;&#24577;&#20998;&#37197;&#12290;&#36825;&#20123;&#20869;&#23384;&#22359;&#21253;&#25324;&#65306;&#20869;&#26680;&#25152;&#21344;&#29992;&#22320;&#22336;&#31354;&#38388;&#21644;bootmem&#32467;&#26500;&#25152;&#21344;&#29992;&#22320;&#22336;&#31354;&#38388;&#12290;
</p><pre class="programlisting">
mm/bootmem.c
int __init reserve_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,
                                 unsigned long size, int flags)
{
        unsigned long start, end;

        start = PFN_DOWN(physaddr);
        end = PFN_UP(physaddr + size);

        return mark_bootmem_node(pgdat-&gt;bdata, start, end, 1, flags);
}

reserve_bootmem_node(pgdat, __pa(&amp;_stext), &amp;_end - &amp;_stext,	BOOTMEM_DEFAULT);
......
reserve_bootmem_node(pgdat, __pa(swapper_pg_dir), PTRS_PER_PGD * sizeof(pgd_t), BOOTMEM_DEFAULT);
</pre><p>
&#27880;&#24847;&#21040;start_pfn&#21644;end_pfn&#23427;&#20204;&#22312;&#24490;&#29615;&#20013;&#25214;&#20986;&#26368;&#23567;&#30340;&#29289;&#29702;&#36215;&#22987;&#22320;&#22336;&#21644;&#26368;&#22823;&#22320;&#22336;&#65292;&#28982;&#21518;&#35760;&#24405;&#29289;&#29702;&#20869;&#23384;&#23545;&#24212;&#39029;&#24103;&#30340;&#32534;&#21495;&#12290;&#30001;&#20110;&#27599;&#20010;&#39029;&#24103;&#22823;&#23567;&#21644;&#20869;&#23384;&#39029;&#22823;&#23567;&#30456;&#21516;&#65288;&#36825;&#26159;&#20026;&#20102;&#26041;&#20415;&#25442;&#39029;&#65289;&#65292;&#20063;&#21363;4K&#65292;&#25152;&#20197;bank_pfn_xxx&#20013;&#36890;&#36807;&#21491;&#31227;PAGE_SHIFT&#26469;&#33719;&#21462;&#39029;&#24103;&#30340;&#32534;&#21495;&#12290;&#32487;&#32493;&#30475;bootmem_init_node&#21518;&#21322;&#37096;&#20998;&#20195;&#30721;&#65292;&#23427;&#20204;&#23545;&#29289;&#29702;&#39029;&#26694;&#25152;&#23545;&#24212;&#30340;&#39029;&#38754;&#36827;&#34892;&#20102;&#20445;&#30041;&#22788;&#29702;&#12290;bootmem&#26159;&#20869;&#26680;&#20013;&#20351;&#29992;&#30340;&#19968;&#31181;&#36739;&#31616;&#21333;&#30340;&#20869;&#23384;&#20998;&#37197;&#31574;&#30053;&#65292;&#23427;&#29992;&#20110;&#22312;&#31995;&#32479;&#21551;&#21160;&#26102;&#20351;&#29992;&#65292;&#22312; buddy&#31561;&#20869;&#23384;&#20998;&#37197;&#31995;&#32479;&#21021;&#22987;&#21270;&#23436;&#25104;&#21518;&#23558;&#19981;&#20877;&#20351;&#29992;&#12290;&#20854;&#22522;&#26412;&#24605;&#24819;&#26159;&#23558;SDRAM&#30340;&#21487;&#29992;&#23384;&#20648;&#31354;&#38388;&#20998;&#25104;&#35768;&#22810;&#39029;&#65292;&#27599;&#39029;&#30340;&#22823;&#23567;&#20026;4K&#65292;&#22312;&#20998;&#37197;&#26102;&#20197;&#39029;&#20026;&#21333;&#20301;&#20998;&#37197;&#65292;&#20998;&#37197;&#26041;&#27861;&#26159;&#20174;&#20302;&#24448;&#39640;&#25214;&#30452;&#21040;&#25214;&#21040;&#19968;&#22359;&#25110;&#36830;&#32493;&#22810;&#22359;&#28385;&#36275;&#22823;&#23567;&#35201;&#27714;&#30340;&#31354;&#38386;&#39029;&#38754;&#20026;&#27490;&#12290;linux&#21551;&#21160;&#26102;&#65292;&#22312;&#20026;&#27599;&#20010;&#29289;&#29702;&#39029;&#38754;&#24314;&#31435;&#23545;&#24212;&#30340;page&#20043;&#21069;&#65292;&#38656;&#35201;&#23558;&#24050;&#32463;&#20351;&#29992;&#36807;&#30340;&#12289;&#20445;&#30041;&#30340;&#29289;&#29702;&#39029;&#38754;&#65288;&#20363;&#22914;&#20869;&#26680;&#20195;&#30721;&#21306;&#12289;&#25968;&#25454;&#21306;&#12289;bss&#21306;&#12289;BIOS&#26144;&#23556;&#21306;&#12289;&#23384;&#25918;3-4G&#30340;&#39029;&#30446;&#24405;&#39029;&#34920;&#21306;&#31561;&#25152;&#21344;&#25454;&#30340;&#29289;&#29702;&#39029;&#38754;&#65289;&#35760;&#19979;&#26469;&#65292;&#35760;&#22312;&#21738;&#37324;&#21602;&#65311;&#23601;&#26159;&#35760;&#36733;node_bootmem_map&#20013;&#65292;&#24314;&#31435;page&#26144;&#23556;&#20043;&#21518;&#65292;&#23558;&#20351;&#29992;&#36807;&#30340;&#12289;&#20445;&#30041;&#30340;&#29289;&#29702;&#39029;&#38754;&#24207;&#21495;&#23646;&#24615;&#37117;&#36890;&#36807;page&#25968;&#32452;&#35760;&#20303;&#20102;&#19979;&#26469;&#65292;&#38543;&#21518;&#23601;&#37322;&#25918;&#25481;bootmem&#12290;
</p><pre class="programlisting">
	/*
	 * If there is no memory in this node, ignore it.
	 */
	if (end_pfn == 0)
		return end_pfn;

	/*
	 * Allocate the bootmem bitmap page.
	 */	
	boot_pages = bootmem_bootmap_pages(end_pfn - start_pfn);
	boot_pfn = find_bootmap_pfn(node, mi, boot_pages);
</pre><p>
&#39318;&#20808;&#21028;&#26029;&#35813;Node&#20013;&#26159;&#21542;&#25552;&#20379;&#20102;&#29289;&#29702;&#20869;&#23384;&#12290;&#25509;&#30528;bootmem_bootmap_pages&#35745;&#31639;&#39029;&#24103;&#32534;&#21495;&#20301;&#22270;&#25152;&#38656;&#21344;&#29992;&#30340;&#39029;&#38754;&#12290;&#29289;&#29702;&#20869;&#23384;&#24320;&#22987;&#22320;&#22336;0x50000000&#65292;&#22823;&#23567;0x10000000&#65292;&#25152;&#20197;&#39029;&#24103;&#32534;&#21495;&#20026;0x50000-0x60000&#12290;bootmem_bootmap_pages&#39318;&#20808;&#26681;&#25454;bootmap_bytes&#35745;&#31639;&#25152;&#26377;&#39029;&#24103;&#25152;&#38656;&#21344;&#29992;&#30340;bytes&#25968;&#65292;&#20026;0x2000&#28982;&#21518;&#21491;&#31227;PAGE_SHIFT&#24471;&#21040;&#39029;&#24103;&#20301;&#22270;&#25152;&#21344;&#30340;&#39029;&#38754;&#25968;&#12290;&#36825;&#37324;&#30340;boot_pages&#34987;&#36171;&#20540;&#20026;2&#12290;
</p><pre class="programlisting">
mm/bootmem.c
static unsigned long __init bootmap_bytes(unsigned long pages)
{
        unsigned long bytes = (pages + 7) / 8;

        return ALIGN(bytes, sizeof(long));
}

/**
 * bootmem_bootmap_pages - calculate bitmap size in pages
 * @pages: number of pages the bitmap has to represent
 */
unsigned long __init bootmem_bootmap_pages(unsigned long pages)
{
        unsigned long bytes = bootmap_bytes(pages);

        return PAGE_ALIGN(bytes) &gt;&gt; PAGE_SHIFT;
}
</pre><p>
find_bootmap_pfn&#26597;&#25214;&#23384;&#25918;&#20301;&#22270;&#31649;&#29702;&#39029;&#30340;&#29289;&#29702;&#39029;&#24103;&#21495;&#65292;&#23454;&#38469;&#26159;&#23384;&#25918;&#21040;_end&#21518;&#30340;&#21518;&#32493;&#39029;&#20013;&#12290;&#20551;&#22914;_end&#30340;&#22320;&#22336;&#23545;&#24212;0xc0539c2e&#65292;&#37027;&#20040;&#29289;&#29702;&#39029;&#24103;&#22320;&#22336;&#20026;
0x50539c2e&#21491;&#31227;12&#20301;&#24471;&#21040;0x50539&#65292;&#37027;&#20040;boot_pfn&#20195;&#34920;&#20102;&#19979;&#19968;&#39029;&#65292;&#25152;&#20197;&#20540;&#20026;0x5053a&#12290;&#27492;&#26102;&#30340;&#20301;&#22270;&#25152;&#22312;&#20869;&#23384;&#20998;&#37197;&#22914;&#19979;&#22270;&#25152;&#31034;&#65306;
</p><div class="figure"><a name="idp80718956"></a><p class="title"><b>&#22270; 50. &#20869;&#23384;&#20301;&#22270;RAM&#24067;&#23616;</b></p><div class="figure-contents"><div><img src="images/m_map.gif" alt="&#20869;&#23384;&#20301;&#22270;RAM&#24067;&#23616;"></div></div></div><p><br class="figure-break">
</p><pre class="programlisting">
mm/page_alloc.c
struct pglist_data __refdata contig_page_data = { .bdata = &amp;bootmem_node_data[0] };
EXPORT_SYMBOL(contig_page_data);

include/linux/bootmem.h
typedef struct bootmem_data {
        unsigned long node_min_pfn;
        unsigned long node_low_pfn;
        void *node_bootmem_map;
        unsigned long last_end_off;
        unsigned long hint_idx;
        struct list_head list;
} bootmem_data_t;

mm/bootmem.c
bootmem_data_t bootmem_node_data[MAX_NUMNODES] __initdata;

include/linux/mmzone.h
typedef struct pglist_data {
        struct zone node_zones[MAX_NR_ZONES];
        struct zonelist node_zonelists[MAX_ZONELISTS];
        int nr_zones;
        ......
} pg_data_t;

extern struct pglist_data contig_page_data;
#define NODE_DATA(nid)          (&amp;contig_page_data)
#define NODE_MEM_MAP(nid)       mem_map
</pre><p>
</p><pre class="programlisting">
mm/bootmem.c
unsigned long __init init_bootmem_node(pg_data_t *pgdat, unsigned long freepfn,
				unsigned long startpfn, unsigned long endpfn)
{
	return init_bootmem_core(pgdat-&gt;bdata, freepfn, startpfn, endpfn);
}

static unsigned long __init init_bootmem_core(bootmem_data_t *bdata,
        unsigned long mapstart, unsigned long start, unsigned long end)
{
        unsigned long mapsize;

        mminit_validate_memmodel_limits(&amp;start, &amp;end);
        bdata-&gt;node_bootmem_map = phys_to_virt(PFN_PHYS(mapstart));
        bdata-&gt;node_min_pfn = start;
        bdata-&gt;node_low_pfn = end;
        link_bootmem(bdata);

        /*
         * Initially all pages are reserved - setup_arch() has to
         * register free RAM areas explicitly.
         */
        mapsize = bootmap_bytes(end - start);
        memset(bdata-&gt;node_bootmem_map, 0xff, mapsize);

        bdebug("nid=%td start=%lx map=%lx end=%lx mapsize=%lx\n",
                bdata - bootmem_node_data, start, mapstart, end, mapsize);

        return mapsize;
}

	node_set_online(node);
	pgdat = NODE_DATA(node);
	init_bootmem_node(pgdat, boot_pfn, start_pfn, end_pfn);
</pre><p>
NODE_DATA&#22312;&#22810;&#33410;&#28857;&#25968;&#32452;&#20013;&#21462;&#20986;&#20026;nid &#30340;&#33410;&#28857;&#30340;&#25551;&#36848;&#25968;&#25454;&#32467;&#26500;&#65292;&#36825;&#37324;&#30452;&#25509;&#33719;&#21462;contig_page_data&#12290;init_bootmem_node&#36890;&#36807;&#30452;&#25509;&#35843;&#29992;init_bootmem_core&#23558;map_pg&#24320;&#22987;&#30340;&#20301;&#22270;&#31649;&#29702;&#31354;&#38388;&#20840;&#37096;&#32622;0xff&#65292;(pgdat-&gt;bdata&#21363;&#20026;bootmem_node_data[0]&#12290;mminit_validate_memmodel_limits&#29992;&#26469;&#39564;&#35777;&#29289;&#29702;&#39029;&#26694;&#30340;&#22823;&#23567;&#65292;&#23545;&#20110;32&#20301;&#30340;4G&#31354;&#38388;&#26469;&#35828;&#65292;&#29289;&#29702;&#39029;&#26694;&#30340;&#33539;&#22260;&#20026;0-0x100000&#12290;&#26174;&#28982;&#36825;&#37324;&#30340;start&#20026;0x50000&#21644;end&#20026;0x60000&#65292;&#23427;&#20204;&#33853;&#22312;&#35813;&#22320;&#22336;&#33539;&#22260;&#20869;&#12290;phys_to_virt&#23558;&#20301;&#22270;&#39029;&#24320;&#22987;&#30340;&#39029;&#21495;&#36716;&#25442;&#20026;&#34394;&#25311;&#22320;&#22336;&#65292;&#36825;&#37324;&#26082;&#26159;&#23558;0x5053a&#36716;&#25442;&#20026;0xc053a000&#12290;node_min_pfn&#21644;node_low_pfn&#20998;&#21035;&#35760;&#24405;&#20102;&#26368;&#23567;&#21644;&#26368;&#22823;&#29289;&#29702;&#39029;&#26694;&#12290;&#25152;&#26377;&#30340;bdata&#31867;&#22411;&#37117;&#34987;link_bootmem&#25918;&#20837;&#21517;&#20026;bdata_list&#30340;&#38142;&#34920;&#20013;&#32479;&#19968;&#31649;&#29702;&#12290;
</p><pre class="programlisting">
static struct list_head bdata_list __initdata = LIST_HEAD_INIT(bdata_list);

static void __init link_bootmem(bootmem_data_t *bdata)
{
        struct list_head *iter;

        list_for_each(iter, &amp;bdata_list) {
                bootmem_data_t *ent;

                ent = list_entry(iter, bootmem_data_t, list);
                if (bdata-&gt;node_min_pfn &lt; ent-&gt;node_min_pfn)
                        break;
        }
        list_add_tail(&amp;bdata-&gt;list, iter);
}
</pre><p>
&#22914;&#26524;&#25171;&#24320;&#20102;bdebug&#65292;&#37027;&#20040;&#23558;&#21487;&#20197;&#24471;&#21040;&#22914;&#19979;&#36755;&#20986;&#12290;
</p><pre class="programlisting">
bootmem::init_bootmem_core nid=0 start=50000 map=5053a end=60000 mapsize=2000
</pre><p>
free_bootmem_node&#37322;&#25918;&#34394;&#25311;&#22320;&#22336;bank_phys_start(bank)&#24320;&#22987;&#22823;&#23567;&#20026;bank_phys_size(bank)&#25152;&#26377;&#29289;&#29702;&#22320;&#22336;&#23545;&#24212;&#30340;&#20301;&#22270;&#65292;&#36825;&#37324;&#20063;&#21363;&#20026;0x50000000&#65292;&#22823;&#23567;&#20026;0x10000000&#12290;
</p><pre class="programlisting">
	for_each_nodebank(i, mi, node) {
		struct membank *bank = &amp;mi-&gt;bank[i];
		free_bootmem_node(pgdat, bank_phys_start(bank), bank_phys_size(bank));
		memory_present(node, bank_pfn_start(bank), bank_pfn_end(bank));
	}
</pre><p>
mark_bootmem_node&#30340;reserve&#21442;&#25968;&#34920;&#26126;&#26159;&#20445;&#30041;&#36824;&#26159;&#21487;&#29992;&#12290;free_bootmem_node&#22312;&#35843;&#29992;&#23427;&#26159;&#35813;&#20540;&#20026;0&#65292;&#25152;&#20197;&#20026;&#21487;&#29992;&#12290;
</p><pre class="programlisting">
void __init free_bootmem_node(pg_data_t *pgdat, unsigned long physaddr,
                              unsigned long size)
{
        unsigned long start, end;

        start = PFN_UP(physaddr);
        end = PFN_DOWN(physaddr + size);

        mark_bootmem_node(pgdat-&gt;bdata, start, end, 0, 0);
}

static int __init mark_bootmem_node(bootmem_data_t *bdata,
                                unsigned long start, unsigned long end,
                                int reserve, int flags)
{
        unsigned long sidx, eidx;

        bdebug("nid=%td start=%lx end=%lx reserve=%d flags=%x\n",
                bdata - bootmem_node_data, start, end, reserve, flags);

        BUG_ON(start &lt; bdata-&gt;node_min_pfn);
        BUG_ON(end &gt; bdata-&gt;node_low_pfn);

        sidx = start - bdata-&gt;node_min_pfn;
        eidx = end - bdata-&gt;node_min_pfn;

        if (reserve)
                return __reserve(bdata, sidx, eidx, flags);
        else
                __free(bdata, sidx, eidx);
        return 0;
}
</pre><p>
</p><pre class="programlisting">
bootmem::mark_bootmem_node nid=0 start=50000 end=60000 reserve=0 flags=0
</pre><p>
sidx&#21644;eidx&#20998;&#21035;&#34920;&#31034;&#29289;&#29702;&#39029;&#26694;&#20301;&#22270;&#30340;&#24320;&#22987;&#21644;&#32467;&#26463;&#30340;&#32034;&#24341;&#65292;&#20063;&#21363;&#30456;&#23545;&#20110;node_min_pfn&#30340;&#20559;&#31227;&#12290;&#30001;&#20110;&#26377;0x10000&#20010;&#39029;&#26694;&#65292;sidx&#36825;&#37324;&#20026;0&#65292;&#32780;eidx&#20026;0x10000&#12290;
</p><pre class="programlisting">
static int __init __reserve(bootmem_data_t *bdata, unsigned long sidx,
                        unsigned long eidx, int flags)
{
        unsigned long idx;
        int exclusive = flags &amp; BOOTMEM_EXCLUSIVE;

        bdebug("nid=%td start=%lx end=%lx flags=%x\n",
                bdata - bootmem_node_data,
                sidx + bdata-&gt;node_min_pfn,
                eidx + bdata-&gt;node_min_pfn,
                flags);

        for (idx = sidx; idx &lt; eidx; idx++)
                if (test_and_set_bit(idx, bdata-&gt;node_bootmem_map)) {
                        if (exclusive) {
                                __free(bdata, sidx, idx);
                                return -EBUSY;
                        }
                        bdebug("silent double reserve of PFN %lx\n",
                                idx + bdata-&gt;node_min_pfn);
                }
        return 0;
}
</pre><p>
__reserve&#35843;&#29992;test_and_set_bit&#65292;&#20063;&#21363;&#35774;&#32622;sidx&#21644;eidx&#20043;&#38388;&#30340;&#25152;&#26377;&#27604;&#29305;&#20301;&#20026;1&#12290;&#27880;&#24847;&#23427;&#30340;flags&#21442;&#25968;&#65292;&#24403;flags&#30340;BOOTMEM_EXCLUSIVE&#20301;&#26159;&#33021;&#20351;&#65292;&#22914;&#26524;&#22312;&#35774;&#32622;&#27604;&#29305;&#20301;&#26102;&#21457;&#29983;EBUSY&#38169;&#35823;&#65292;&#37027;&#20040;&#30452;&#25509;&#36820;&#22238;&#12290;
</p><pre class="programlisting">
static void __init __free(bootmem_data_t *bdata,
                        unsigned long sidx, unsigned long eidx)
{
        unsigned long idx;

        bdebug("nid=%td start=%lx end=%lx\n", bdata - bootmem_node_data,
                sidx + bdata-&gt;node_min_pfn,
                eidx + bdata-&gt;node_min_pfn);

        if (bdata-&gt;hint_idx &gt; sidx)
                bdata-&gt;hint_idx = sidx;

        for (idx = sidx; idx &lt; eidx; idx++)
                if (!test_and_clear_bit(idx, bdata-&gt;node_bootmem_map))
                        BUG();
}
</pre><p>
hint_idx&#21017;&#35760;&#24405;&#20102;&#26368;&#23567;&#30340;&#21487;&#29992;&#30340;&#32034;&#24341;&#20301;&#32622;&#12290;__free&#19982;__reserve&#27491;&#22909;&#30456;&#21453;&#65292;&#23427;&#35843;&#29992;test_and_clear_bit&#65292;&#20063;&#21363;&#28165;&#38500;sidx&#21644;eidx&#20043;&#38388;&#30340;&#25152;&#26377;&#27604;&#29305;&#20301;&#20026;1&#12290;
</p><pre class="programlisting">
bootmem::__free nid=0 start=50000 end=60000
</pre><p>
&#22914;&#26524;&#27809;&#26377;&#23450;&#20041;&#36825;&#20010;   CONFIG_HAVE_MEMORY_PRESENT &#23439;&#23450;&#20041;&#65292;&#36825;&#20010;&#20989;&#25968;&#20026;&#31354;&#20989;&#25968;&#65292;&#36825;&#37324;&#26410;&#23450;&#20041;&#12290;
</p><pre class="programlisting">
#ifdef CONFIG_HAVE_MEMORY_PRESENT
void memory_present(int nid, unsigned long start, unsigned long end);
#else
static inline void memory_present(int nid, unsigned long start, unsigned long end) {}
#endif
</pre><p>
</p><pre class="programlisting">
	/*
	 * Reserve the bootmem bitmap for this node.
	 */
	reserve_bootmem_node(pgdat, boot_pfn &lt;&lt; PAGE_SHIFT,
			     boot_pages &lt;&lt; PAGE_SHIFT, BOOTMEM_DEFAULT);

	return end_pfn;
}
</pre><p>
bootmem_init_node&#30340;&#26368;&#21518;&#39044;&#30041;&#29289;&#29702;&#20301;&#22270;&#25152;&#21344;&#29992;&#30340;&#20004;&#20010;&#39029;&#26694;&#30340;&#20301;&#22270;&#20026;1&#65292;&#27492;&#26102;&#21487;&#20197;&#23581;&#35797;&#35835;&#21462;0xc053a000[41]&#65292;&#23427;&#30340;&#20540;&#20026;0xc000000&#65292;&#26174;&#28982;&#20854;&#20013;&#30340;bit 1&#23545;&#24212;&#21040;&#30340;&#32034;&#24341;&#20026;0x5053a&#21644;0x5053b&#12290;</p><div class="figure"><a name="idp80731532"></a><p class="title"><b>&#22270; 51. &#20301;&#22270;&#24067;&#23616;</b></p><div class="figure-contents"><div><img src="images/m_bitmap.gif" alt="&#20301;&#22270;&#24067;&#23616;"></div></div></div><p><br class="figure-break">
</p>
<p>
bootmem_init&#22312;&#35843;&#29992;bootmem_init_node&#21021;&#22987;&#21270;&#19968;&#20010;&#20869;&#23384;&#33410;&#28857;&#21518;&#65292;&#23558;&#20250;&#36827;&#34892;&#19968;&#20123;&#39044;&#30041;&#25805;&#20316;&#12290;
</p><pre class="programlisting">
      /*
       * Reserve any special node zero regions.
       */
      if (node == 0)
              reserve_node_zero(NODE_DATA(node));
</pre><p>
reserve_node_zero&#23545;NODE 0&#20570;&#19968;&#31995;&#21015;&#30340;&#20445;&#30041;&#21160;&#20316;&#12290;
</p><pre class="programlisting">
/*
 * Reserve the various regions of node 0
 */
void __init reserve_node_zero(pg_data_t *pgdat)
{
	unsigned long res_size = 0;

	/*
	 * Register the kernel text and data with bootmem.
	 * Note that this can only be in node 0.
	 */
#ifdef CONFIG_XIP_KERNEL
	reserve_bootmem_node(pgdat, __pa(&amp;__data_start), &amp;_end - &amp;__data_start,
			BOOTMEM_DEFAULT);
#else
	reserve_bootmem_node(pgdat, __pa(&amp;_stext), &amp;_end - &amp;_stext,
			BOOTMEM_DEFAULT);
#endif
</pre><p>
&#30001;&#20110;&#27809;&#26377;&#23450;&#20041;CONFIG_XIP_KERNEL&#65292;&#25152;&#20197;&#30452;&#25509;&#25191;&#34892;&#23545;_stext&#21644;_end&#21306;&#22495;&#23545;&#24212;&#29289;&#29702;&#39029;&#26694;&#30340;&#20445;&#30041;&#65292;&#20063;&#21363;&#23545;&#20869;&#26680;&#25152;&#22312;&#30340;&#20869;&#23384;&#38236;&#20687;&#21306;&#36827;&#34892;&#20445;&#30041;&#22788;&#29702;&#12290;
</p><pre class="programlisting">
bootmem::mark_bootmem_node nid=0 start=50008 end=5053a reserve=1 flags=0
</pre><p>

</p><pre class="programlisting">
	/*
	 * Reserve the page tables.  These are already in use,
	 * and can only be in node 0.
	 */
	reserve_bootmem_node(pgdat, __pa(swapper_pg_dir),
			     PTRS_PER_PGD * sizeof(pgd_t), BOOTMEM_DEFAULT);
</pre><p>	
&#20445;&#30041;&#39029;&#34920;&#25152;&#22312;&#30340;&#21306;&#22495;0x50004000&#21040;0x50008000&#21306;&#22495;&#12290;
</p><pre class="programlisting">
	bootmem::mark_bootmem_node nid=0 start=50004 end=50008 reserve=1 flags=0
</pre><p>
&#25509;&#19979;&#26469;&#23545;&#29305;&#23450;&#30340;&#26426;&#22120;&#26550;&#26500;&#20570;&#19968;&#20123;&#29305;&#27530;&#30340;&#21306;&#22495;&#20445;&#30041;&#65292;S3C6410&#27809;&#26377;&#29992;&#21040;&#12290;
</p><pre class="programlisting">
	/*
	 * Hmm... This should go elsewhere, but we really really need to
	 * stop things allocating the low memory; ideally we need a better
	 * implementation of GFP_DMA which does not assume that DMA-able
	 * memory starts at zero.
	 */
	if (machine_is_integrator() || machine_is_cintegrator())
		res_size = __pa(swapper_pg_dir) - PHYS_OFFSET;

	/*
	 * These should likewise go elsewhere.  They pre-reserve the
	 * screen memory region at the start of main system memory.
	 */
	if (machine_is_edb7211())
		res_size = 0x00020000;
	if (machine_is_p720t())
		res_size = 0x00014000;

	/* H1940 and RX3715 need to reserve this for suspend */

	if (machine_is_h1940() || machine_is_rx3715()) {
		reserve_bootmem_node(pgdat, 0x30003000, 0x1000,
				BOOTMEM_DEFAULT);
		reserve_bootmem_node(pgdat, 0x30081000, 0x1000,
				BOOTMEM_DEFAULT);
	}
</pre><p>
CONFIG_SA1111&#20063;&#26410;&#23450;&#20041;&#65292;&#25152;&#20197;&#36825;&#37324;&#30452;&#25509;&#36339;&#36807;&#12290;
</p><pre class="programlisting">
#ifdef CONFIG_SA1111
	/*
	 * Because of the SA1111 DMA bug, we want to preserve our
	 * precious DMA-able memory...
	 */
	res_size = __pa(swapper_pg_dir) - PHYS_OFFSET;
#endif
	if (res_size)
		reserve_bootmem_node(pgdat, PHYS_OFFSET, res_size,
				BOOTMEM_DEFAULT);
}
</pre><p>	
&#25509;&#19979;&#26469;&#23545;initrd&#21306;&#22495;&#36827;&#34892;&#20445;&#30041;&#22788;&#29702;&#65292;&#30001;&#20110;&#27809;&#26377;&#20351;&#29992;initrd&#65292;&#25152;&#20197;&#36825;&#37324;&#30340;initrd_node&#20540;&#20026;-2&#65292;&#30452;&#25509;&#36339;&#36807;&#12290;
</p><pre class="programlisting">
		if (node == initrd_node)
			bootmem_reserve_initrd(node);
</pre><p>	
&#25509;&#30528;&#35760;&#24405;&#26368;&#22823;&#30340;&#20869;&#23384;PFN&#65292;&#21363;&#26368;&#22823;&#39029;&#26694;&#32534;&#21495;&#12290;&#26174;&#28982;&#36825;&#37324;&#30340;memend_pfn&#20026;0x60000&#12290;
</p><pre class="programlisting">
		/*
		 * Remember the highest memory PFN.
		 */		
		if (end_pfn &gt; memend_pfn)
			memend_pfn = end_pfn;
}			
</pre><p>
&#21040;&#36825;&#37324;bootmem_init&#20013;&#30340;&#20027;&#24490;&#29615;&#23601;&#22788;&#29702;&#23436;&#27605;&#20102;&#65292;&#23454;&#38469;&#19978;&#30001;&#20110;&#21482;&#26377;&#19968;&#20010;&#20869;&#23384;Bank&#65292;&#23545;&#24212;&#20102;&#19968;&#20010;Node&#65292;&#36825;&#37324;&#30340;&#24490;&#29615;&#21482;&#22788;&#29702;&#20102;&#19968;&#27425;&#12290;
&#34987;&#20445;&#23384;&#30340;&#21306;&#22495;&#22914;&#19979;&#25152;&#31034;&#65306;
</p><pre class="programlisting">
bootmem::mark_bootmem_node nid=0 start=5053a end=5053c reserve=1 flags=0
bootmem::mark_bootmem_node nid=0 start=50008 end=5053a reserve=1 flags=0
bootmem::mark_bootmem_node nid=0 start=50004 end=50008 reserve=1 flags=0
</pre><p>
</p>
&#19979;&#22270;&#20013;&#21487;&#20197;&#30475;&#21040;3&#20010;&#20445;&#30041;&#21306;&#26159;&#36830;&#32493;&#30340;&#23427;&#20204;&#23545;&#24212;&#21040;&#30340;&#20301;&#22270;&#22312;c053a000:0xf0&#21644;c053a0a7:0x0f&#33539;&#22260;&#20869;&#65292;&#20197;&#21450;&#31471;&#28857;bytes&#20013;&#30340;4bits&#12290;
<div class="figure"><a name="idp80703412"></a><p class="title"><b>&#22270; 52. &#20869;&#23384;&#20301;&#22270;&#20445;&#30041;&#21306;</b></p><div class="figure-contents"><div><img src="images/m_map1.gif" alt="&#20869;&#23384;&#20301;&#22270;&#20445;&#30041;&#21306;"></div></div></div><br class="figure-break">
<pre class="programlisting">
	sparse_init();
	
	/*
	 * Now free memory in each node - free_area_init_node needs
	 * the sparse mem_map arrays initialized by sparse_init()
	 * for memmap_init_zone(), otherwise all PFNs are invalid.
	 */
	for_each_node(node)
		bootmem_free_node(node, mi);	
</pre>
sparse_init&#21482;&#26377;&#22312;&#37197;&#32622;CONFIG_SPARSEMEM&#26102;&#25165;&#26377;&#25928;&#65292;&#21542;&#21017;&#20026;&#31354;&#20989;&#25968;&#12290;bootmem_free_node&#20026;mem_map&#20445;&#25345;&#29289;&#29702;&#39029;&#26694;&#12290;zone_size[n]&#23545;&#24212;NODE n&#65292;&#36825;&#37324;&#30340;zone_size[0]&#21363;&#20026;&#24403;&#21069;&#31995;&#32479;&#20013;&#29289;&#29702;&#20869;&#23384;&#30340;&#39029;&#24103;&#25968;0x10000&#12290;zhole_size&#29992;&#26469;&#23384;&#20648;&#35813;NODE&#20013;&#23380;&#27934;&#30340;&#22823;&#23567;&#65292;&#23427;&#36890;&#36807;&#24635;&#22823;&#23567;&#20943;&#21435;&#35813;NODE&#20013;bank&#30340;&#22823;&#23567;&#65292;&#30001;&#20110;&#36825;&#37324;&#21482;&#26377;&#19968;&#20010;bank&#65292;&#25152;&#20197;&#19981;&#23384;&#22312;&#23380;&#27934;&#12290;&#20063;&#21363;zhole_size[0]&#20026;0&#12290;arch_adjust_zones&#29992;&#26469;&#22788;&#29702;&#29305;&#23450;&#26426;&#22120;&#26550;&#26500;&#30340;&#29305;&#27530;&#38656;&#27714;&#65292;&#36825;&#37324;&#20026;&#31354;&#12290;
<pre class="programlisting">
mm/init.c
static void __init bootmem_free_node(int node, struct meminfo *mi)
{
	unsigned long zone_size[MAX_NR_ZONES], zhole_size[MAX_NR_ZONES];
	unsigned long start_pfn, end_pfn;
	pg_data_t *pgdat = NODE_DATA(node);
	int i;

	start_pfn = pgdat-&gt;bdata-&gt;node_min_pfn;
	end_pfn = pgdat-&gt;bdata-&gt;node_low_pfn;

  ......

	/*
	 * The size of this node has already been determined.  If we need
	 * to do anything fancy with the allocation of this memory to the
	 * zones, now is the time to do it.
	 */
	zone_size[0] = end_pfn - start_pfn;

	/*
	 * For each bank in this node, calculate the size of the holes.
	 *  holes = node_size - sum(bank_sizes_in_node)
	 */
	zhole_size[0] = zone_size[0];
	for_each_nodebank(i, mi, node)
		zhole_size[0] -= bank_pfn_size(&amp;mi-&gt;bank[i]);

	/*
	 * Adjust the sizes according to any special requirements for
	 * this machine type.
	 */
	arch_adjust_zones(node, zone_size, zhole_size);

	free_area_init_node(node, zone_size, start_pfn, zhole_size);
}
</pre>
MAX_NR_ZONES&#22312;&#32534;&#35793;&#26102;&#33258;&#21160;&#29983;&#25104;&#65292;&#23427;&#30340;&#20540;&#19982;__MAX_NR_ZONES&#20445;&#25345;&#30456;&#31561;&#12290;ZONE&#29992;&#20110;&#31649;&#29702;&#20869;&#23384;&#30340;&#29992;&#36884;&#12290;&#27599;&#19968;&#20010;ZONE&#21306;&#37117;&#26377;&#33258;&#24049;&#30340;buddy system&#26469;&#31649;&#29702;&#23646;&#20110;&#33258;&#24049;&#30340;&#36830;&#32493;&#20869;&#23384;&#39029;&#65292;&#26681;&#25454;&#20869;&#26680;&#37197;&#32622;&#21487;&#20197;&#36873;&#25321;&#20351;&#33021;ZONE_DMA&#21644;ZONE_HIGHMEM&#12290;&#24403;&#21069;&#31995;&#32479;&#21482;&#20351;&#29992;&#20102;ZONE_DMA&#65292;ZONE_NORMAL&#21644;ZONE_MOVABLE&#21306;&#12290;
<pre class="programlisting">
include/linux/bounds.h
#define NR_PAGEFLAGS 22 /* __NR_PAGEFLAGS       @ */
#define MAX_NR_ZONES 3 /* __MAX_NR_ZONES        @ */

include/linux/mmzone.h
enum zone_type {
#ifdef CONFIG_ZONE_DMA
        ZONE_DMA,
#endif
 	ZONE_NORMAL,
 #ifdef CONFIG_HIGHMEM
        ZONE_HIGHMEM,
#endif
        ZONE_MOVABLE,
        __MAX_NR_ZONES
};	
</pre>
calculate_node_totalpages&#36827;&#34892;&#19968;&#20123;&#39029;&#38754;&#32479;&#35745;&#30340;&#36816;&#31639;&#24182;&#23384;&#20837;pgdat&#32467;&#26500;&#25104;&#21592;&#20013;&#12290;
<pre class="programlisting">
mm/page_alloc.c
void __paginginit free_area_init_node(int nid, unsigned long *zones_size,
                unsigned long node_start_pfn, unsigned long *zholes_size)
{
        pg_data_t *pgdat = NODE_DATA(nid);

        pgdat-&gt;node_id = nid;
        pgdat-&gt;node_start_pfn = node_start_pfn;
        calculate_node_totalpages(pgdat, zones_size, zholes_size);

        alloc_node_mem_map(pgdat);
#ifdef CONFIG_FLAT_NODE_MEM_MAP
        printk(KERN_DEBUG "free_area_init_node: node %d, pgdat %08lx, node_mem_map %08lx\n",
                nid, (unsigned long)pgdat,
                (unsigned long)pgdat-&gt;node_mem_map);
#endif

        free_area_init_core(pgdat, zones_size, zholes_size);
}
</pre>
<pre class="programlisting">
free_area_init_node: node 0, pgdat c04ed144, node_mem_map c053e000
</pre>
calculate_node_totalpages&#35745;&#31639;&#26412;NODE&#25152;&#26377;&#20869;&#23384;&#39029;&#25968;&#24635;&#21644;&#65288;&#21253;&#25324;&#20869;&#23384;&#23380;&#27934;&#30340;&#65289;&#23384;&#20837;node_spanned_pages&#65292;&#25152;&#26377;&#20869;&#23384;&#39029;&#21306;&#30340;&#23454;&#38469;&#39029;&#25968;&#65288;&#19981;&#21253;&#25324;&#20869;&#23384;&#23380;&#27934;&#30340;&#65289;&#23384;&#20837;node_present_pages&#12290;
<pre class="programlisting">
static void __meminit calculate_node_totalpages(struct pglist_data *pgdat,
		unsigned long *zones_size, unsigned long *zholes_size)
{
	unsigned long realtotalpages, totalpages = 0;
	enum zone_type i;

	for (i = 0; i &lt; MAX_NR_ZONES; i++)
		totalpages += zone_spanned_pages_in_node(pgdat-&gt;node_id, i,
								zones_size);
	pgdat-&gt;node_spanned_pages = totalpages;

	realtotalpages = totalpages;
	for (i = 0; i &lt; MAX_NR_ZONES; i++)
		realtotalpages -=
			zone_absent_pages_in_node(pgdat-&gt;node_id, i,
								zholes_size);
	pgdat-&gt;node_present_pages = realtotalpages;
	printk(KERN_DEBUG "On node %d totalpages: %lu\n", pgdat-&gt;node_id,
							realtotalpages);
}
</pre>
<pre class="programlisting">
calculate_node_totalpages= On node 0 totalpages: 65536
</pre>
&#27599;&#19968;&#20010;&#29289;&#29702;&#39029;&#26694;&#23545;&#24212;&#19968;&#20010;struct page&#32467;&#26500;&#65292;alloc_node_mem_map&#23601;&#29992;&#26469;&#20026;&#25152;&#26377;&#30340;&#29289;&#29702;&#39029;&#38754;&#20998;&#37197;&#35813;&#32467;&#26500;&#20307;&#31354;&#38388;&#12290;
<pre class="programlisting">
static void __init_refok alloc_node_mem_map(struct pglist_data *pgdat)
{
	/* Skip empty nodes */
	if (!pgdat-&gt;node_spanned_pages)
		return;

#ifdef CONFIG_FLAT_NODE_MEM_MAP
	/* ia64 gets its own node_mem_map, before this, without bootmem */
	if (!pgdat-&gt;node_mem_map) {
		unsigned long size, start, end;
		struct page *map;

		/*
		 * The zone's endpoints aren't required to be MAX_ORDER
		 * aligned but the node_mem_map endpoints must be in order
		 * for the buddy allocator to function correctly.
		 */
		start = pgdat-&gt;node_start_pfn &amp; ~(MAX_ORDER_NR_PAGES - 1);
		end = pgdat-&gt;node_start_pfn + pgdat-&gt;node_spanned_pages;
		end = ALIGN(end, MAX_ORDER_NR_PAGES);
		size =  (end - start) * sizeof(struct page);
		map = alloc_remap(pgdat-&gt;node_id, size);
		if (!map)
			map = alloc_bootmem_node(pgdat, size);
		pgdat-&gt;node_mem_map = map + (pgdat-&gt;node_start_pfn - start);
	}
</pre>
start&#21644;end&#20998;&#21035;&#20195;&#34920;&#20102;&#36215;&#27490;&#39029;&#24103;0x50000&#21644;0x60000&#65292;size&#21017;&#20195;&#34920;&#20102;&#24403;&#21069;&#25152;&#26377;&#39029;&#24103;&#23545;&#24212;&#30340;struct page&#32467;&#26500;&#20307;&#30340;&#22823;&#23567;&#12290;&#21482;&#26377;&#23450;&#20041;&#20102;CONFIG_HAVE_ARCH_ALLOC_REMAP&#65292;alloc_remap&#25165;&#26377;&#24847;&#20041;&#65292;&#21542;&#21017;&#20026;&#31354;&#20989;&#25968;&#65292;&#27492;&#26102;&#35843;&#29992;alloc_bootmem_node&#12290;
<pre class="programlisting">
include/linux/bootmem.h
#ifdef CONFIG_HAVE_ARCH_ALLOC_REMAP
extern void *alloc_remap(int nid, unsigned long size);
#else
static inline void *alloc_remap(int nid, unsigned long size)
{
        return NULL;
}
#endif /* CONFIG_HAVE_ARCH_ALLOC_REMAP */
......

#define MAX_DMA_ADDRESS			0x40000000
#define alloc_bootmem_node(pgdat, x) \
        __alloc_bootmem_node(pgdat, x, SMP_CACHE_BYTES, __pa(MAX_DMA_ADDRESS))

mm/bootmem.c
void * __init __alloc_bootmem_node(pg_data_t *pgdat, unsigned long size,
				   unsigned long align, unsigned long goal)
{
	return ___alloc_bootmem_node(pgdat-&gt;bdata, size, align, goal, 0);
}

static void * __init ___alloc_bootmem_node(bootmem_data_t *bdata,
				unsigned long size, unsigned long align,
				unsigned long goal, unsigned long limit)
{
	void *ptr;

	ptr = alloc_bootmem_core(bdata, size, align, goal, limit);
	if (ptr)
		return ptr;

	return ___alloc_bootmem(size, align, goal, limit);
}
</pre>
alloc_bootmem_node&#35843;&#29992;__alloc_bootmem_node&#65292;&#20174;&#32780;&#35843;&#29992;___alloc_bootmem_node&#12290;alloc_bootmem_node&#26159;&#19968;&#20010;&#30456;&#24403;&#22797;&#26434;&#30340;&#20989;&#25968;&#12290;
<pre class="programlisting">	
#ifndef CONFIG_NEED_MULTIPLE_NODES
	/*
	 * With no DISCONTIG, the global mem_map is just set as node 0's
	 */
	if (pgdat == NODE_DATA(0)) {
		mem_map = NODE_DATA(0)-&gt;node_mem_map;
#ifdef CONFIG_ARCH_POPULATES_NODE_MAP
		if (page_to_pfn(mem_map) != pgdat-&gt;node_start_pfn)
			mem_map -= (pgdat-&gt;node_start_pfn - ARCH_PFN_OFFSET);
#endif /* CONFIG_ARCH_POPULATES_NODE_MAP */
	}
#endif
#endif /* CONFIG_FLAT_NODE_MEM_MAP */
}
</pre>

<pre class="programlisting">
static void * __init alloc_bootmem_core(struct bootmem_data *bdata,
				unsigned long size, unsigned long align,
				unsigned long goal, unsigned long limit)
{
	unsigned long fallback = 0;
	unsigned long min, max, start, sidx, midx, step;

	BUG_ON(!size);
	BUG_ON(align &amp; (align - 1));
	BUG_ON(limit &amp;&amp; goal + size &gt; limit);

	if (!bdata-&gt;node_bootmem_map)
		return NULL;

	bdebug("nid=%td size=%lx [%lu pages] align=%lx goal=%lx limit=%lx\n",
		bdata - bootmem_node_data, size, PAGE_ALIGN(size) &gt;&gt; PAGE_SHIFT,
		align, goal, limit);
	
	min = bdata-&gt;node_min_pfn;
	max = bdata-&gt;node_low_pfn;

	goal &gt;&gt;= PAGE_SHIFT;
	limit &gt;&gt;= PAGE_SHIFT;

	if (limit &amp;&amp; max &gt; limit)
		max = limit;
	if (max &lt;= min)
		return NULL;

	step = max(align &gt;&gt; PAGE_SHIFT, 1UL);  
	if (goal &amp;&amp; min &lt; goal &amp;&amp; goal &lt; max)
		start = ALIGN(goal, step);
	else
		start = ALIGN(min, step);

	sidx = start - bdata-&gt;node_min_pfn;
	midx = max - bdata-&gt;node_min_pfn;
	
	if (bdata-&gt;hint_idx &gt; sidx) {
		/*
		 * Handle the valid case of sidx being zero and still
		 * catch the fallback below.
		 */
		fallback = sidx + 1;
		sidx = align_idx(bdata, bdata-&gt;hint_idx, step);
	}
</pre>
goal&#30340;&#20540;&#20195;&#34920;&#20102;&#25351;&#23450;&#30340;&#34394;&#22320;&#22336;&#65292;&#22914;&#26524;&#35813;&#22320;&#22336;&#23545;&#24212;&#30340;&#29289;&#29702;&#22320;&#22336;&#33853;&#22312;&#23454;&#38469;&#30340;RAM&#22320;&#22336;&#33539;&#22260;&#20869;&#65292;&#37027;&#20040;&#20351;&#29992;&#35813;&#22320;&#22336;&#20316;&#20026;struct page&#20998;&#37197;&#30340;&#22320;&#22336;&#65292;&#21542;&#21017;&#20351;&#29992;node_min_pfn&#35745;&#31639;&#24320;&#22987;&#22320;&#22336;&#12290;ALIGN&#26681;&#25454;SMP_CACHE_BYTES&#20570;&#23545;&#40784;&#65292;&#23427;&#30340;&#20540;&#36890;&#24120;&#20026;32&#12290;&#20197;&#19978;&#30340;&#35745;&#31639;&#26368;&#32456;&#30446;&#30340;&#26159;&#20026;&#20102;&#33719;&#21462;sidx&#21644;midx&#12290;
<pre class="programlisting">
bootmem::alloc_bootmem_core nid=0 size=200000 [512 pages] align=20 goal=d0000000 limit=0
</pre>
&#25509;&#19979;&#26469;&#30340;find_block&#23558;&#23581;&#35797;&#22312;bitmap&#20013;&#26597;&#25214;&#19968;&#22359;&#36830;&#32493;&#30340;&#21487;&#20351;&#29992;&#30340;&#21306;&#22495;&#65292;&#22914;&#26524;&#19981;&#33021;&#28385;&#36275;&#36830;&#32493;&#30340;&#35201;&#27714;&#65292;&#37027;&#20040;&#23558;&#25345;&#32493;&#36339;&#36716;&#21040;find_block&#12290;&#36825;&#37324;&#26597;&#25214;&#21040;0x53e-0x73e&#39033;&#30340;bitmap&#20026;&#31354;&#65292;&#23427;&#20204;&#32039;&#25509;&#22312;bitmap&#25152;&#22312;&#39029;&#30340;&#21518;&#38754;&#12290;&#25152;&#20197;&#23545;&#24212;&#30340;&#39029;&#22320;&#22336;&#20174;0xc053c000&#24320;&#22987;&#65292;&#22823;&#23567;&#20026;512&#20010;&#39029;&#38754;&#12290;
<pre class="programlisting">
	while (1) {
		int merge;
		void *region;
		unsigned long eidx, i, start_off, end_off;
find_block:
		sidx = find_next_zero_bit(bdata-&gt;node_bootmem_map, midx, sidx);
		sidx = align_idx(bdata, sidx, step);
		eidx = sidx + PFN_UP(size);

		if (sidx &gt;= midx || eidx &gt; midx)
			break;

		for (i = sidx; i &lt; eidx; i++)
			if (test_bit(i, bdata-&gt;node_bootmem_map)) {
				sidx = align_idx(bdata, i, step);
				if (sidx == i)
					sidx += step;
				goto find_block;
			}

		if (bdata-&gt;last_end_off &amp; (PAGE_SIZE - 1) &amp;&amp;
				PFN_DOWN(bdata-&gt;last_end_off) + 1 == sidx)
			start_off = align_off(bdata, bdata-&gt;last_end_off, align);
		else
			start_off = PFN_PHYS(sidx);

		merge = PFN_DOWN(start_off) &lt; sidx;
		end_off = start_off + size;

		bdata-&gt;last_end_off = end_off;
		bdata-&gt;hint_idx = PFN_UP(end_off);

		/*
		 * Reserve the area now:
		 */
		if (__reserve(bdata, PFN_DOWN(start_off) + merge,
				PFN_UP(end_off), BOOTMEM_EXCLUSIVE))
			BUG();

		region = phys_to_virt(PFN_PHYS(bdata-&gt;node_min_pfn) +
				start_off);
		memset(region, 0, size);
		return region;
	}

	if (fallback) {
		sidx = align_idx(bdata, fallback - 1, step);
		fallback = 0;
		goto find_block;
	}

	return NULL;
}
</pre>
__reserve&#30340;&#21306;&#38388;&#22914;&#19979;&#25152;&#31034;&#65292;&#32039;&#25509;&#30528;&#35843;&#29992;memset&#23558;&#36825;&#20123;&#21306;&#22495;&#28165;&#38646;&#12290;
<pre class="programlisting">
bootmem::__reserve nid=0 start=5053e end=5073e flags=1
</pre>
&#27492;&#26102;&#20869;&#23384;&#30340;&#20998;&#24067;&#22914;&#19979;&#22270;&#25152;&#31034;&#65306;
<div class="figure"><a name="idp80754860"></a><p class="title"><b>&#22270; 53. &#20869;&#23384;&#20998;&#24067;&#22270;</b></p><div class="figure-contents"><div><img src="images/m_map2.gif" alt="&#20869;&#23384;&#20998;&#24067;&#22270;"></div></div></div><br class="figure-break">
&#32487;&#32493;&#35266;&#23519;free_area_init_node&#30340;&#26368;&#21518;&#37096;&#20998;&#12290;
<pre class="programlisting">
#ifdef CONFIG_FLAT_NODE_MEM_MAP
        printk(KERN_DEBUG "free_area_init_node: node %d, pgdat %08lx, node_mem_map %08lx\n",
                nid, (unsigned long)pgdat,
                (unsigned long)pgdat-&gt;node_mem_map);
#endif

        free_area_init_core(pgdat, zones_size, zholes_size);
</pre>
free_area_init_core &#23450;&#20041;&#22312;page_alloc.c&#20013;&#65292;&#23427;&#34987;&#29992;&#26469;&#21021;&#22987;&#21270;&#31649;&#29702;&#21306;zone&#12290;
<p>
&#22312;&#20256;&#32479;&#30340;&#35745;&#31639;&#26426;&#32467;&#26500;&#20013;&#65292;&#25972;&#20010;&#29289;&#29702;&#20869;&#23384;&#37117;&#26159;&#22343;&#21248;&#19968;&#33268;&#30340;&#65292;CPU&#35775;&#38382;&#36825;&#20010;&#31354;&#38388;&#20013;&#30340;&#20219;&#20309;&#19968;&#20010;&#22320;&#22336;&#25152;&#38656;&#35201;&#30340;&#26102;&#38388;&#37117;&#30456;&#21516;&#65292;&#25152;&#20197;&#25226;&#36825;&#31181;&#20869;&#23384;&#31216;&#20026;&#8220;&#19968;&#33268;&#23384;&#20648;&#32467;&#26500;&#65288;Uniform Memory Architecture&#65289;&#8221;&#65292;&#31616;&#31216;UMA&#12290;&#21487;&#26159;&#65292;&#22312;&#19968;&#20123;&#26032;&#30340;&#31995;&#32479;&#32467;&#26500;&#20013;&#65292;&#29305;&#21035;&#26159;&#22810;CPU&#32467;&#26500;&#30340;&#31995;&#32479;&#20013;&#65292;&#29289;&#29702;&#23384;&#20648;&#31354;&#38388;&#22312;&#36825;&#26041;&#38754;&#30340;&#19968;&#33268;&#24615;&#21364;&#25104;&#20102;&#38382;&#39064;&#12290;&#36825;&#26159;&#22240;&#20026;&#65292;&#22312;&#22810;CPU&#32467;&#26500;&#20013;&#65292;&#31995;&#32479;&#20013;&#21482;&#26377;&#19968;&#26465;&#24635;&#32447;&#65288;&#20363;&#22914;&#65292;PCI&#24635;&#32447;&#65289;&#65292;&#26377;&#22810;&#20010;CPU&#27169;&#22359;&#36830;&#25509;&#22312;&#31995;&#32479;&#24635;&#32447;&#19978;&#65292;&#27599;&#20010;CPU&#27169;&#22359;&#37117;&#26377;&#26412;&#22320;&#30340;&#29289;&#29702;&#20869;&#23384;&#65292;&#20294;&#26159;&#20063;&#21487;&#20197;&#36890;&#36807;&#31995;&#32479;&#24635;&#32447;&#35775;&#38382;&#20854;&#23427;CPU&#27169;&#22359;&#19978;&#30340;&#20869;&#23384;&#12290;&#21478;&#22806;&#65292;&#31995;&#32479;&#24635;&#32447;&#19978;&#36824;&#36830;&#25509;&#30528;&#19968;&#20010;&#20844;&#29992;&#30340;&#23384;&#20648;&#27169;&#22359;&#65292;&#25152;&#26377;&#30340;CPU&#27169;&#22359;&#37117;&#21487;&#20197;&#36890;&#36807;&#31995;&#32479;&#24635;&#32447;&#26469;&#35775;&#38382;&#23427;&#12290;&#22240;&#27492;&#65292;&#25152;&#26377;&#36825;&#20123;&#29289;&#29702;&#20869;&#23384;&#30340;&#22320;&#22336;&#21487;&#20197;&#20114;&#30456;&#36830;&#32493;&#32780;&#24418;&#25104;&#19968;&#20010;&#36830;&#32493;&#30340;&#29289;&#29702;&#22320;&#22336;&#31354;&#38388;&#12290;</p>
<p>
&#26174;&#28982;&#65292;&#23601;&#26576;&#20010;&#29305;&#23450;&#30340;CPU&#32780;&#35328;&#65292;&#35775;&#38382;&#20854;&#26412;&#22320;&#30340;&#23384;&#20648;&#22120;&#36895;&#24230;&#26159;&#26368;&#24555;&#30340;&#65292;&#32780;&#31359;&#36807;&#31995;&#32479;&#24635;&#32447;&#35775;&#38382;&#20844;&#29992;&#23384;&#20648;&#27169;&#22359;&#25110;&#20854;&#23427;CPU&#27169;&#22359;&#19978;&#30340;&#23384;&#20648;&#22120;&#23601;&#27604;&#36739;&#24930;&#65292;&#32780;&#19988;&#36824;&#38754;&#20020;&#22240;&#21487;&#33021;&#30340;&#31454;&#20105;&#32780;&#24341;&#36215;&#30340;&#19981;&#30830;&#23450;&#24615;&#12290;&#20063;&#23601;&#26159;&#35828;&#65292;&#22312;&#36825;&#26679;&#30340;&#31995;&#32479;&#20013;&#65292;&#20854;&#29289;&#29702;&#23384;&#20648;&#31354;&#38388;&#34429;&#28982;&#22320;&#22336;&#36830;&#32493;&#65292;&#20294;&#22240;&#20026;&#25152;&#22788;&#8220;&#20301;&#32622;&#8221;&#19981;&#21516;&#32780;&#23548;&#33268;&#30340;&#23384;&#21462;&#36895;&#24230;&#19981;&#19968;&#33268;&#65292;&#25152;&#20197;&#31216;&#20026;&#8220;&#38750;&#19968;&#33268;&#23384;&#20648;&#32467;&#26500;&#65288;Non-Uniform Memory Architecture&#65289;&#65292;&#31616;&#31216;NUMA&#12290;</p>
<p>&#20107;&#23454;&#19978;&#65292;&#20005;&#26684;&#24847;&#20041;&#19978;&#30340;UMA&#32467;&#26500;&#20960;&#20046;&#19981;&#23384;&#22312;&#12290;&#23601;&#25343;&#37197;&#32622;&#26368;&#31616;&#21333;&#30340;&#21333;CPU&#26469;&#35828;&#65292;&#20854;&#29289;&#29702;&#23384;&#20648;&#31354;&#38388;&#23601;&#21253;&#25324;&#20102;RAM&#12289;ROM&#65288;&#29992;&#20110;BIOS&#65289;&#65292;&#36824;&#26377;&#22270;&#24418;&#21345;&#19978;&#30340;&#38745;&#24577;RAM&#12290;&#20294;&#26159;&#65292;&#22312;UMA&#20013;&#65292;&#38500;&#20027;&#23384;RAM&#20043;&#22806;&#30340;&#23384;&#20648;&#22120;&#31354;&#38388;&#37117;&#24456;&#23567;&#65292;&#22240;&#27492;&#21487;&#20197;&#25226;&#23427;&#20204;&#25918;&#22312;&#29305;&#27530;&#30340;&#22320;&#22336;&#19978;&#65292;&#22312;&#32534;&#31243;&#26102;&#21152;&#20197;&#29305;&#21035;&#27880;&#24847;&#23601;&#34892;&#65292;&#37027;&#20040;&#65292;&#21487;&#20197;&#35748;&#20026;&#20197;RAM&#20026;&#20027;&#20307;&#30340;&#20027;&#23384;&#26159;UMA&#32467;&#26500;&#12290;</p>
<p>&#30001;&#20110;NUMA&#30340;&#24341;&#20837;&#65292;&#23601;&#38656;&#35201;&#23384;&#20648;&#31649;&#29702;&#26426;&#21046;&#30340;&#25903;&#25345;&#65292;&#22240;&#27492;&#65292;Linux&#20869;&#26680;&#20174;2.4&#29256;&#26412;&#24320;&#22987;&#23601;&#25552;&#20379;&#20102;&#23545;NUMA&#30340;&#25903;&#25345;&#65288;&#20316;&#20026;&#19968;&#20010;&#32534;&#35793;&#21487;&#36873;&#39033;&#65289;&#12290;&#20026;&#20102;&#23545;NUMA&#36827;&#34892;&#25551;&#36848;&#65292;&#24341;&#20837;&#19968;&#20010;&#26032;&#30340;&#27010;&#24565;&#65293;&#8220;&#23384;&#20648;&#33410;&#28857;(&#25110;&#21483;&#33410;&#28857;)&#8221;&#65292;&#25226;&#35775;&#38382;&#26102;&#38388;&#30456;&#21516;&#30340;&#23384;&#20648;&#31354;&#38388;&#23601;&#21483;&#20570;&#19968;&#20010;&#8220;&#23384;&#20648;&#33410;&#28857;&#8221;&#12290;&#19968;&#33324;&#26469;&#35828;&#65292;&#36830;&#32493;&#30340;&#29289;&#29702;&#39029;&#38754;&#24212;&#35813;&#20998;&#37197;&#22312;&#30456;&#21516;&#30340;&#23384;&#20648;&#33410;&#28857;&#19978;&#12290;&#20363;&#22914;&#65292;&#22914;&#26524;CPU&#27169;&#22359;1&#35201;&#27714;&#20998;&#37197;5&#20010;&#39029;&#38754;&#65292;&#20294;&#26159;&#30001;&#20110;&#26412;&#27169;&#22359;&#19978;&#30340;&#23384;&#20648;&#31354;&#38388;&#24050;&#32463;&#19981;&#22815;&#65292;&#21482;&#33021;&#20998;&#37197;3&#20010;&#39029;&#38754;&#65292;&#37027;&#20040;&#27492;&#26102;&#65292;&#26159;&#25226;&#21478;&#22806;&#20004;&#20010;&#39029;&#38754;&#20998;&#37197;&#22312;&#20854;&#23427;CPU&#27169;&#22359;&#19978;&#21602;&#65292;&#36824;&#26159;&#25226;5&#20010;&#39029;&#38754;&#24178;&#33030;&#20998;&#37197;&#22312;&#19968;&#20010;&#27169;&#22359;&#19978;&#65311;&#26174;&#28982;&#65292;&#21512;&#29702;&#30340;&#20998;&#37197;&#26041;&#24335;&#22240;&#35813;&#26159;&#23558;&#36825;5&#20010;&#39029;&#38754;&#37117;&#20998;&#37197;&#22312;&#20844;&#29992;&#27169;&#22359;&#19978;&#12290;</p>
<p>Linux&#25226;&#29289;&#29702;&#20869;&#23384;&#21010;&#20998;&#20026;&#19977;&#20010;&#23618;&#27425;&#26469;&#31649;&#29702;&#65306;&#23384;&#20648;&#33410;&#28857;&#65288;Node&#65289;&#12289;&#31649;&#29702;&#21306;&#65288;Zone&#65289;&#21644;&#39029;&#38754;&#65288;Page&#65289;&#65292;&#24182;&#29992;&#19977;&#20010;&#30456;&#24212;&#30340;&#25968;&#25454;&#32467;&#26500;&#26469;&#25551;&#36848;&#12290;&#23427;&#20204;&#30340;&#20851;&#31995;&#22914;&#19979;&#22270;&#25152;&#31034;&#65306;
</p>
<p>Linux&#29992;&#19968;&#20010;struct pg_data_t&#32467;&#26500;&#26469;&#25551;&#36848;&#31995;&#32479;&#30340;&#20869;&#23384;&#65292;&#31995;&#32479;&#20013;&#27599;&#20010;&#32467;&#28857;&#37117;&#25346;&#25509;&#22312;&#19968;&#20010;pgdat_list&#21015;&#34920;&#20013;&#65292;&#23545;UMA&#20307;&#31995;&#32467;&#26500;&#65292;&#21017;&#21482;&#26377;&#19968;&#20010;&#38745;&#24577;&#30340;pg_data_t&#32467;&#26500;contig_page_data&#12290;</p>
</div>
<div class="sect2" title="9.10. devicemaps_init"><div class="titlepage"><div><div><h3 class="title"><a name="idp80702844"></a>9.10. devicemaps_init</h3></div></div></div>
<p>
bootmem_init&#20026;&#20869;&#23384;&#21019;&#24314;&#39029;&#34920;&#26144;&#23556;&#65292;devicemaps_init&#30340;&#20316;&#29992;&#21017;&#26159;&#21019;&#24314;&#35774;&#22791;&#30456;&#20851;&#30340;I/O&#21306;&#30340;&#39029;&#34920;&#26144;&#23556;&#65292;&#20063;&#21363;&#35774;&#22791;&#39029;&#34920;&#12290;
</p><pre class="programlisting">
static void __init devicemaps_init(struct machine_desc *mdesc)
{
	struct map_desc map;
	unsigned long addr;
	void *vectors;

	/*
	 * Allocate the vector page early.
	 */
	vectors = alloc_bootmem_low_pages(PAGE_SIZE);
	BUG_ON(!vectors);

	for (addr = VMALLOC_END; addr; addr += PGDIR_SIZE)
		pmd_clear(pmd_off_k(addr));
</pre><p>
&#39318;&#20808;&#28165;&#38500;[VMALLOC_END, 0xffffffff]&#34394;&#25311;&#22320;&#22336;&#21306;&#23545;&#24212;&#30340;&#19968;&#32423;&#39029;&#34920;&#24182;&#22312;TLB&#28165;&#38500;&#23545;&#24212;&#30340;&#39029;&#34920;&#32531;&#23384;&#12290;PGDIR_SIZE&#22823;&#23567;&#34987;&#23450;&#20041;&#20026;2M&#65292;pmd_clear&#27599;&#27425;&#22788;&#29702;&#20004;&#20010;&#39029;&#34920;&#12290;
</p><pre class="programlisting">
	/*
	 * Create a mapping for the machine vectors at the high-vectors
	 * location (0xffff0000).  If we aren't using high-vectors, also
	 * create a mapping at the low-vectors virtual address.
	 */
	map.pfn = __phys_to_pfn(virt_to_phys(vectors));
	map.virtual = 0xffff0000;
	map.length = PAGE_SIZE;	
	map.type = MT_HIGH_VECTORS;	
	create_mapping(&amp;map);
	
	if (!vectors_high()) {
		map.virtual = 0;
		map.type = MT_LOW_VECTORS;		
		create_mapping(&amp;map);
	}
</pre><p>
&#25509;&#30528;&#21019;&#24314;&#24322;&#24120;&#21521;&#37327;&#34920;&#30340;&#39029;&#38754;&#26144;&#23556;&#12290;&#23545;&#20110;ARMv4&#20197;&#19979;&#30340;&#29256;&#26412;&#65292;&#36825;&#20010;&#22320;&#22336;&#22266;&#23450;&#20026;0&#65307;ARMv4&#21450;&#20854;&#20197;&#19978;&#30340;&#29256;&#26412;&#65292;ARM&#24322;&#24120;&#21521;&#37327;&#34920;&#30340;&#22320;&#22336;&#21463;&#21327;&#22788;&#29702;&#22120;CP15 &#30340;c1 &#23492;&#23384;&#22120;(control register)&#20013;V &#20301;(bit[13]) &#30340;&#25511;&#21046;&#65292; &#22914;&#26524;V=1 &#65292; &#21017;&#24322;&#24120;&#21521;&#37327;&#34920;&#30340;&#22320;&#22336;&#20026;0x00000000~0x0000001C&#65307;&#22914;&#26524;V=0&#65292;&#21017;&#20026;:0xffff0000~0xffff001C&#12290;cr_alignment&#22312;entry-armv.S&#20013;&#23450;&#20041;&#65292;&#22312;&#20869;&#26680;&#21021;&#22987;&#21270;&#26102;&#20445;&#23384;CP15&#30340;&#25511;&#21046;&#23492;&#23384;&#22120;c1&#30340;&#20540;&#65292;&#21442;&#32771;arch/arm/kernel/head-common.S&#20013;&#30340;__mmap_switched&#35843;&#29992;&#36807;&#31243;&#12290;
</p><pre class="programlisting">
arch/arm/include/asm/system.h

extern unsigned long cr_alignment;	/* defined in entry-armv.S */
#if __LINUX_ARM_ARCH__ &gt;= 4
#define vectors_high()  (cr_alignment &amp; CR_V)
#else
#define vectors_high()  (0)
#endif
</pre><p>
&#28982;&#21518;&#25191;&#34892;&#26426;&#22120;&#25551;&#36848;&#31526;mdesc&#21442;&#25968;&#20013;&#25552;&#20379;&#30340;map_io&#20989;&#25968;&#12290;
</p><pre class="programlisting">
	/*
	 * Ask the machine support to map in the statically mapped devices.
	 */
	if (mdesc-&gt;map_io)
		mdesc-&gt;map_io();

</pre><p>
&#23545;&#20110;s3c6410&#65292;mdesc&#30340;&#23450;&#20041;&#21442;&#32771;<a class="xref" href="ar01s08.html#mach_type" title="8.3. &#26816;&#26597;&#26426;&#22120;&#31867;&#22411;">&#31532; 8.3 &#33410; &#8220;&#26816;&#26597;&#26426;&#22120;&#31867;&#22411;&#8221;</a>&#65292;&#35813;&#20989;&#25968;&#34987;&#23450;&#20041;&#20026;smdk6410_map_io&#12290;&#39318;&#20808;&#35843;&#29992;s3c64xx_init_io&#21021;&#22987;&#21270;&#20869;&#23384;&#26144;&#23556;&#12290;
</p><pre class="programlisting">
arch/arm/mach-s3c6410/mach-smdk6410.c
struct map_desc smdk6410_iodesc[] = {
{
        .virtual        = (u32)S3C64XX_VA_DM9000,
        .pfn            = __phys_to_pfn(S3C64XX_PA_DM9000),
        .length         = S3C64XX_SZ_DM9000,
        .type           = MT_DEVICE,
},};
static void __init smdk6410_map_io(void)
{
        s3c_device_nand.name = "s3c6410-nand";

        s3c64xx_init_io(smdk6410_iodesc, ARRAY_SIZE(smdk6410_iodesc));
        s3c24xx_init_clocks(12000000);
        s3c24xx_init_uarts(smdk6410_uartcfgs, ARRAY_SIZE(smdk6410_uartcfgs));
        s3c64xx_reserve_bootmem();
}
</pre><p>
s3c64xx_init_io&#26368;&#32456;&#20250;&#35843;&#29992;iotable_init-&lt;create_mapping&#26469;&#21019;&#24314;&#35774;&#22791;&#39029;&#34920;&#12290;&#20256;&#36882;&#30340;smdk6410_iodesc&#21442;&#25968;&#29992;&#26469;&#23454;&#29616;DM9000A&#32593;&#21345;&#22806;&#35774;&#30340;&#22320;&#22336;&#26144;&#23556;&#12290;
</p><pre class="programlisting">
arch/arm/plat-s3c64xx/cpu.c
static struct map_desc s3c_iodesc[] __initdata = {
	{
		.virtual	= (unsigned long)S3C_VA_SYS,
		.pfn		= __phys_to_pfn(S3C64XX_PA_SYSCON),
		.length		= SZ_4K,
		.type		= MT_DEVICE,
	}, {......
	
arch/arm/mm/mmu.c
void __init iotable_init(struct map_desc *io_desc, int nr)
{
	int i;

	for (i = 0; i &lt; nr; i++)
		create_mapping(io_desc + i);
}

arch/arm/plat-s3c64xx/cpu.c
void __init s3c64xx_init_io(struct map_desc *mach_desc, int size)
{
  unsigned long idcode;
	
  /* initialise the io descriptors we need for initialisation */
  iotable_init(s3c_iodesc, ARRAY_SIZE(s3c_iodesc));
  iotable_init(mach_desc, size);
  
  idcode = __raw_readl(S3C_SYS_ID);
  s3c_init_cpu(idcode, cpu_ids, ARRAY_SIZE(cpu_ids));
}
</pre><p>
</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">&#39318;&#20808;iotable_init&#27880;&#20876;S3C64xx&#31995;&#21015;CPU&#36890;&#29992;&#30340;iomap&#65292;&#23427;&#20204;&#34987;&#23450;&#20041;&#22312;s3c_iodesc&#25968;&#32452;&#20013;&#12290;</li><li class="listitem">&#25509;&#30528;&#23558;&#20256;&#36882;&#26469;&#30340;smdk6410_iodesc&#36827;&#34892;&#26144;&#23556;&#65292;&#23427;&#38024;&#23545;DM9000A&#32593;&#21345;&#12290;</li><li class="listitem">&#26368;&#21518;&#35835;&#21462;S3C_SYS_ID&#65292;&#28982;&#21518;s3c_init_cpu&#20989;&#25968;&#20174;64xx&#31995;&#21015;CPU&#25968;&#32452;cpu_ids&#20013;&#36873;&#25321;&#23545;&#24212;&#30340;CPU&#65292;&#24182;&#25191;&#34892;&#20102;&#29305;&#23450;CPU&#30340;map_io&#20989;&#25968;&#12290;</li></ul></div><p>
</p><pre class="programlisting">
static struct cpu_table cpu_ids[] __initdata = {
	......
	{
		.idcode		= 0x36410100,
		.idmask		= 0xffffff00,
		.map_io		= s3c6410_map_io,
		.init_clocks	= s3c6410_init_clocks,
		.init_uarts	= s3c6410_init_uarts,
		.init		= s3c6410_init,
		.name		= name_s3c6410,
	},
};

void __init s3c_init_cpu(unsigned long idcode,
			 struct cpu_table *cputab, unsigned int cputab_size)
{
	cpu = s3c_lookup_cpu(idcode, cputab, cputab_size);
......
	cpu-&gt;map_io();
}
</pre><p>
s3c6410_map_io&#23545;s3c6410_iodesc&#23450;&#20041;&#25968;&#32452;&#36827;&#34892;&#26144;&#23556;&#12290;&#20027;&#35201;&#38024;&#23545;LCD&#65292;SROM&#25511;&#21046;&#22120;&#21644;USB&#22806;&#35774;&#26144;&#23556;&#22320;&#22336;&#12290;
</p><pre class="programlisting">
arch/arm/mach-s3c6410/cpu.c
static struct map_desc s3c6410_iodesc[] __initdata = {
	IODESC_ENT(LCD),
	IODESC_ENT(SROMC),
	IODESC_ENT(HOSTIFB),
	IODESC_ENT(OTG),
	IODESC_ENT(OTGSFR),
};

void __init s3c6410_map_io(void)
{
	iotable_init(s3c6410_iodesc, ARRAY_SIZE(s3c6410_iodesc));

	/* initialise device information early */
	s3c6410_default_sdhci0();
	s3c6410_default_sdhci1();
	s3c6410_default_sdhci2();

	/* the i2c devices are directly compatible with s3c2440 */
	s3c_i2c0_setname("s3c2440-i2c");
	s3c_i2c1_setname("s3c2440-i2c");

	/* set our idle function */
	s3c64xx_idle = s3c6410_idle;
}
</pre><p>
&#23545;&#24212;s3c_iodesc&#25968;&#32452;&#26469;&#35828;&#65292;&#20570;&#20102;&#22914;&#19979;&#26144;&#23556;&#65306;
</p><div class="table"><a name="idp80770060"></a><p class="title"><b>&#34920; 11. &#39029;&#34920;&#35774;&#22791;&#21015;&#34920;</b></p><div class="table-contents">
<table summary="&#39029;&#34920;&#35774;&#22791;&#21015;&#34920;" border="1"><colgroup><col><col></colgroup><thead><tr><th>&#34394;&#25311;&#22320;&#22336;</th><th>&#29289;&#29702;&#22320;&#22336;</th><th>&#22823;&#23567;</th><th>&#26144;&#23556;&#31867;&#22411;</th></tr></thead><tbody><tr><td>S3C_VA_SYS</td><td>S3C64XX_PA_SYSCON</td><td>SZ_4K</td><td>MT_DEVICE</td></tr><tr><td>3C_VA_UART + UART_OFFS</td><td>S3C_PA_UART</td><td>SZ_4K</td><td>MT_DEVICE</td></tr><tr><td>S3C_VA_VIC0</td><td>S3C64XX_PA_VIC0</td><td>SZ_16K</td><td>MT_DEVICE</td></tr><tr><td>S3C_VA_VIC1</td><td>S3C64XX_PA_VIC1</td><td>SZ_16K</td><td>MT_DEVICE</td></tr><tr><td>S3C_VA_TIMER</td><td>S3C_PA_TIMER</td><td>SZ_16K</td><td>MT_DEVICE</td></tr><tr><td>S3C64XX_VA_GPIO</td><td>S3C64XX_PA_GPIO</td><td>SZ_4K</td><td>MT_DEVICE</td></tr></tbody></table>
</div></div><p><br class="table-break">
s3c24xx_init_clocks&#29992;&#26469;&#35774;&#32622;PLL&#26230;&#25391;&#20540;&#20026;12MHz&#12290;s3c24xx_init_uarts&#21021;&#22987;&#21270;&#20018;&#21475;&#65292;&#25152;&#26377;&#22312;Bootloader&#31227;&#20132;&#20869;&#26680;&#21551;&#21160;&#30340;&#25171;&#21360;&#20449;&#24687;&#37117;&#26159;&#22312;&#35813;&#20989;&#25968;&#25191;&#34892;&#21518;&#25165;&#30495;&#27491;&#36755;&#20986;&#21040;&#32456;&#31471;&#30340;&#65292;&#23558;&#26102;&#38047;&#21644;&#32456;&#31471;&#21021;&#22987;&#21270;&#25918;&#22312;map_io&#20989;&#25968;&#20013;&#26174;&#28982;&#19981;&#26159;&#22909;&#30340;&#36873;&#25321;&#12290;s3c64xx_reserve_bootmem&#20026;&#23450;&#20041;&#22312;s3c_mdevs&#20013;&#30340;DMA&#35774;&#22791;&#21015;&#34920;&#36890;&#36807;Bootmem&#26426;&#21046;&#39044;&#30041;&#19968;&#20123;&#20869;&#23384;&#12290;
</p><pre class="programlisting">
arch/arm/plat-s3c64xx/bootmem.c
void s3c64xx_reserve_bootmem(void)
{
        struct s3c_media_device *mdev;
        int i;

        for(i = 0; i &lt; sizeof(s3c_mdevs) / sizeof(s3c_mdevs[0]); i++) {
                mdev = &amp;s3c_mdevs[i];
                if (mdev-&gt;memsize &gt; 0) {
                        mdev-&gt;paddr = virt_to_phys(alloc_bootmem_low(mdev-&gt;memsize));
                        printk(KERN_INFO \
                                "s3c64xx: %lu bytes SDRAM reserved "
                                "for %s at 0x%08x\n",
                                (unsigned long) mdev-&gt;memsize, \
                                mdev-&gt;name, mdev-&gt;paddr);
                }
        }
}
</pre><p>
&#26368;&#21518;&#21047;&#26032;TLB&#20197;&#21450;Cache&#12290;
</p><pre class="programlisting">
	/*
	 * Finally flush the caches and tlb to ensure that we're in a
	 * consistent state wrt the writebuffer.  This also ensures that
	 * any write-allocated cache lines in the vector page are written
	 * back.  After this point, we can start to touch devices again.
	 */
	local_flush_tlb_all();
	flush_cache_all();
}
</pre><p>
</p>
</div>
<div class="sect2" title="9.11. 0&#39029;"><div class="titlepage"><div><div><h3 class="title"><a name="idp80778508"></a>9.11. 0&#39029;</h3></div></div></div>
paging_init&#30340;&#26368;&#21518;&#37096;&#20998;&#30340;&#20195;&#30721;&#27604;&#36739;&#31616;&#21333;&#12290;
<pre class="programlisting">
	top_pmd = pmd_off_k(0xffff0000);

	/*
	 * allocate the zero page.  Note that we count on this going ok.
	 */
	zero_page = alloc_bootmem_low_pages(PAGE_SIZE);
	memzero(zero_page, PAGE_SIZE);
	empty_zero_page = virt_to_page(zero_page);
	flush_dcache_page(empty_zero_page);
}
</pre>
top_pmd&#24341;&#29992;&#20102;32&#20301;4G&#34394;&#25311;&#22320;&#22336;&#31354;&#38388;&#26368;&#39640;&#22788;&#30340;&#39029;&#34920;&#65292;&#23427;&#34987;&#29992;&#22312;&#39640;&#31471;&#20869;&#23384;&#35775;&#38382;&#20013;&#12290;
<pre class="programlisting">
/*
 * The pmd table for the upper-most set of pages.
 */
pmd_t *top_pmd;
</pre>
&#25509;&#19979;&#26469;&#20998;&#37197;1&#20010;&#39029;&#38754;&#22823;&#23567;&#30340;0&#39029;&#65292;&#35813;&#21306;&#22495;&#34987;memzero&#20989;&#25968;&#21021;&#22987;&#21270;&#20026;&#20840;0&#12290;0&#39029;&#34987;&#29992;&#20316;0&#39029;&#25335;&#36125;&#65292;&#21487;&#20197;&#24555;&#36895;&#21021;&#22987;&#21270;&#38656;&#35201;&#28165;0&#30340;&#20869;&#23384;&#39029;&#38754;&#12290;
<pre class="programlisting">
arch/arm/include/asm/pgtable.h

/*
 * ZERO_PAGE is a global shared page that is always zero: used
 * for zero-mapped memory areas etc..
 */
extern struct page *empty_zero_page;
#define ZERO_PAGE(vaddr)        (empty_zero_page)
</pre>
</div>
<div class="footnotes"><br><hr width="100" align="left"><div class="footnote">
<p><sup>[<a name="ftn.idp80665532" href="#idp80665532" class="para">6</a>] </sup>
<pre class="programlisting">
arch/arm/kernel/setup.c
static int __init parse_tag(const struct tag *tag)
{
	extern struct tagtable __tagtable_begin, __tagtable_end;
	struct tagtable *t;

	for (t = &amp;__tagtable_begin; t &lt; &amp;__tagtable_end; t++)
		if (tag-&gt;hdr.tag == t-&gt;tag) {
			t-&gt;parse(tag);
			break;
		}

	return t &lt; &amp;__tagtable_end;
}
</pre>
__tagtable_begin&#21644;__tagtable_end&#22312;vmlinux.lds.S&#20013;&#23450;&#20041;&#65292;&#23427;&#20204;&#21253;&#21547;&#20102;&#21517;&#20026;.taglist.init&#30340;&#27573;&#31867;&#22411;&#12290;
<pre class="programlisting">
arch/arm/kernel/vmlinux.lds.S

__tagtable_begin = .;
        *(.taglist.init)
__tagtable_end = .;
</pre>
.taglist.init&#30340;&#27573;&#36890;&#36807;&#23439;__tagtable&#26469;&#23450;&#20041;&#65292;&#22312;arch/arm/kernel/setup.c&#21644;arch/arm/mm/init.c&#20013;&#21487;&#20197;&#25214;&#21040;&#24456;&#22810;__tagtable&#30340;&#23450;&#20041;&#12290;
<pre class="programlisting">
arch/arm/include/asm/setup.h
struct tagtable {
        __u32 tag;
        int (*parse)(const struct tag *);
};
......
#define __tag __used __attribute__((__section__(".taglist.init")))
#define __tagtable(tag, fn) \
static struct tagtable __tagtable_##fn __tag = { tag, fn }
</pre>
&#19968;&#20010;__tagtable&#23450;&#20041;&#20195;&#34920;&#20102;&#19968;&#20010;struct tagtable&#65292;&#22312;arch/arm&#19979;&#25628;&#32034;__tagtable&#30340;&#32467;&#26524;&#22914;&#19979;&#65306;
<pre class="programlisting">
./mm/init.c:55:__tagtable(ATAG_INITRD, parse_tag_initrd);
./mm/init.c:64:__tagtable(ATAG_INITRD2, parse_tag_initrd2);
......
./kernel/setup.c:538:__tagtable(ATAG_CORE, parse_tag_core);
./kernel/setup.c:552:__tagtable(ATAG_MEM, parse_tag_mem32);
./kernel/setup.c:578:__tagtable(ATAG_VIDEOTEXT, parse_tag_videotext);
./kernel/setup.c:589:__tagtable(ATAG_RAMDISK, parse_tag_ramdisk);
./kernel/setup.c:598:__tagtable(ATAG_SERIAL, parse_tag_serialnr);
./kernel/setup.c:606:__tagtable(ATAG_REVISION, parse_tag_revision);
./kernel/setup.c:614:__tagtable(ATAG_CMDLINE, parse_tag_cmdline);
</pre>
&#23581;&#35797;&#23558;__tagtable(ATAG_MEM, parse_tag_mem32)&#23637;&#24320;&#21487;&#20197;&#24471;&#21040;&#21517;&#20026;__tagtable_parse_tag_mem32&#30340;tag&#34920;&#12290;&#23427;&#30340;&#31867;&#22411;&#34987;&#35774;&#32622;&#20026;ATAG_MEM&#65292;&#23545;&#24212;&#30340;parse&#20989;&#25968;&#20026;parse_tag_mem32&#12290;&#36825;&#20123;tag&#34920;&#34987;&#38142;&#25509;&#21040;__tagtable_begin&#21644;__tagtable_end&#20043;&#38388;&#12290;parse_tag&#23601;&#22312;&#23427;&#20204;&#20043;&#38388;&#35835;&#21462;tag&#34920;&#65292;&#24182;&#26681;&#25454;tag&#31867;&#22411;&#19982;&#20256;&#20837;&#30340;tag&#21442;&#25968;&#30456;&#21305;&#37197;&#12290;&#19968;&#26086;&#21305;&#37197;&#23558;&#35843;&#29992;parse&#20989;&#25968;&#36827;&#34892;&#35299;&#26512;&#12290;&#36825;&#37324;&#20197;parse_tag_mem32&#20026;&#20363;&#65306;
<pre class="programlisting">
static int __init parse_tag_mem32(const struct tag *tag)
{
        if (meminfo.nr_banks &gt;= NR_BANKS) {
                printk(KERN_WARNING
                       "Ignoring memory bank 0x%08x size %dKB\n",
                        tag-&gt;u.mem.start, tag-&gt;u.mem.size / 1024);
                return -EINVAL;
        }
        arm_add_memory(tag-&gt;u.mem.start, tag-&gt;u.mem.size);
        return 0;
}
</pre>
&#19968;&#20010;&#19981;&#33021;&#24573;&#30053;&#30340;&#20107;&#23454;&#26159;&#22312;&#22788;&#29702;ATAG_CMDLINE&#33410;&#28857;&#21442;&#25968;&#26102;&#65292;parse_tag_cmdline&#23558;&#20250;&#25913;&#21464;default_command_line&#30340;&#20540;&#65292;&#25152;&#20197;bootloader&#25552;&#20379;&#30340;bootargs&#21442;&#25968;&#30340;&#20248;&#20808;&#32423;&#35201;&#39640;&#20110;&#20869;&#26680;&#37197;&#32622;&#25991;&#20214;&#20013;&#30340;CONFIG_CMDLINE&#12290;&#19968;&#33324;&#24773;&#20917;&#19979;&#23427;&#20204;&#24212;&#35813;&#20445;&#25345;&#19968;&#33268;&#12290;
<pre class="programlisting">
static int __init parse_tag_cmdline(const struct tag *tag)
{
	strlcpy(default_command_line, tag-&gt;u.cmdline.cmdline, COMMAND_LINE_SIZE);
	return 0;
}
</pre>
NR_BANKS&#23450;&#20041;&#25903;&#25345;&#30340;&#26368;&#22823;&#20869;&#23384;&#22359;&#25968;&#12290;tag-&gt;u.mem.start&#23450;&#20041;&#20102;&#20869;&#23384;&#30340;&#29289;&#29702;&#36215;&#22987;&#22320;&#22336;&#65292;tag-&gt;u.mem.size&#21017;&#23450;&#20041;&#20102;&#20869;&#23384;&#22823;&#23567;&#12290;
<pre class="programlisting">
arch/arm/include/asm/setup.h
# define NR_BANKS 8
struct membank {
        unsigned long start;
        unsigned long size;
        int           node;
};
struct meminfo {
        int nr_banks;
        struct membank bank[NR_BANKS];
};
......
static void __init arm_add_memory(unsigned long start, unsigned long size)
{
	struct membank *bank;

	/*
	 * Ensure that start/size are aligned to a page boundary.
	 * Size is appropriately rounded down, start is rounded up.
	 */
	size -= start &amp; ~PAGE_MASK;

	bank = &amp;meminfo.bank[meminfo.nr_banks++];

	bank-&gt;start = PAGE_ALIGN(start);
	bank-&gt;size  = size &amp; PAGE_MASK;
	bank-&gt;node  = PHYS_TO_NID(start);
}
</pre>
size&#34987;&#23545;&#40784;&#21040;&#39029;&#22823;&#23567;&#12290;nr_banks&#35760;&#24405;&#24050;&#32463;&#27880;&#20876;&#30340;&#20869;&#23384;bank&#65292;&#32780;bank[i]&#25104;&#21592;&#21017;&#35760;&#24405;&#31532;i&#20010;bank&#20869;&#23384;&#30340;&#24320;&#22987;&#22320;&#22336;&#21644;&#22823;&#23567;&#12290;arm_add_memory&#20989;&#25968;&#30340;&#24037;&#20316;&#23601;&#26159;&#25226;atags&#37324;&#38754;&#30340;&#29289;&#29702;&#20869;&#23384;&#20449;&#24687;&#22686;&#21152;&#21040;meminfo&#32467;&#26500;&#12290;
</p>	</div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ar01s08.html">&#19978;&#19968;&#39029;</a> </td><td width="20%" align="center"> </td><td width="40%" align="right"> <a accesskey="n" href="ar01s10.html">&#19979;&#19968;&#39029;</a></td></tr><tr><td width="40%" align="left" valign="top">8. &#20869;&#26680;&#21152;&#36733; </td><td width="20%" align="center"><a accesskey="h" href="index.html">&#36215;&#22987;&#39029;</a></td><td width="40%" align="right" valign="top"> 10. Bootmem&#26426;&#21046;</td></tr></table></div></body></html>
